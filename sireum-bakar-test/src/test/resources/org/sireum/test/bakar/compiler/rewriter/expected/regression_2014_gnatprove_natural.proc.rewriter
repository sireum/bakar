package Natural_Set;


const $CONST {
  Old_Length = (Integer) S.Len;
}

procedure Create (
        T S) {

  #l1.
    S := `T {
      Len = 0ii,
      M = `Set_Array_T { iter => 
          switch iter
            default => Invalid_Element}
    };

  #l2.
    return (S);
}

procedure Insert (
        T S,
        Natural Value) {
  local
    Boolean _tcomp0;


  #l4.
    call _tcomp0 := Contains (S, Value);

  #l5.
    if !(!(_tcomp0)) then goto l3;

  #l6.
    S.Len := S.Len + 1ii;

  #l7.
    S.M[S.Len] := Value;

  #l3.
    // empty loc

  #l8.
    return (S);
}package Natural_Set;


typealias Integer Element_T;

typealias Natural Set_Length;

typealias Set_Length Set_Index;

typealias _ARRAY_ Set_Array_T;

record T {

  Set_Length Len;

  Set_Array_T M;
}

typealias _PRIVATE_TYPE_DECLARATION_ T;

const $CONST {
  Maximum_Set_Size = (Positive) 10ii;

  Invalid_Element = (Element_T) attribute__uif__first `Element_T;
}

procedure Boolean Valid (
        T S) {

}

procedure Natural Members (
        T S) {

}

procedure Boolean Full (
        T S) {
  local
    Natural _tcomp1;


  #l9.
    call _tcomp1 := Members (S);

  #l10.
    return _tcomp1 == Maximum_Set_Size;
}

procedure Create (
        T S) {

}

procedure Boolean Contains (
        T S,
        Natural Value) {

}

procedure Insert (
        T S,
        Natural Value) {

}

procedure Natural Members (
        T S) {

  #l11.
    return S.Len;
}

procedure Boolean Valid (
        T S) {

  #l12.
    return proof__uif__for_all {Set_Index I => 
        switch I
          case (1ii, S.Len) => attribute__uif__first `Natural <= S.M[I] &&& S.M[I] <= attribute__uif__last `Natural
          default => true} && proof__uif__for_all {Set_Index I => 
        switch I
          case (S.Len + 1ii, attribute__uif__last `Set_Index) => S.M[I] == Invalid_Element
          default => true};
}

procedure Boolean Contains (
        T S,
        Natural Value) {
  local
    Natural _tcomp2;


  #l13.
    call _tcomp2 := Members (S);

  #l14.
    return proof__uif__for_some {universal_integer I => 
        switch I
          case (1ii, _tcomp2) => S.M[I] == Value
          default => true};
}package Standard;


typealias Boolean Boolean;

typealias Integer Integer;

typealias Integer Natural;

typealias Integer Positive;

typealias Float Float;

typealias universal_integer universal_integer;

typealias universal_real universal_real;

typealias Character Character;

typealias String String;