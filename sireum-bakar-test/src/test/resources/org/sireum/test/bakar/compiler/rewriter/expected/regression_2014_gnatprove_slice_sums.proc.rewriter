package Slice_Sums;


procedure Slice_Bounds Maximal_Sum_Slice_Bounds (
        Vector X) {
  local
    Natural Max_Sum;
    Slice_Bounds Result;
    Slice_Bounds Current_Slice;
    Integer Current_Sum;
    Index Lo;
    Index _tcomp0;
    Index _tcomp1;
    Index Hi;
    Index _tcomp2;
    Index _tcomp3;
    Integer _tcomp4;


  #l1.
    Max_Sum := 0ii;

  #l2.
    Result := `Slice_Bounds {
      Lo = 1ii,
      Hi = 0ii
    };

  #l4.
    _tcomp0 := attribute__uif__first `X;

  #l5.
    _tcomp1 := attribute__uif__last `X;

  #l6.
    if _tcomp0 > _tcomp1 then goto l3;

  #l7.
    Lo := _tcomp0;

  #l8.
    // empty loc

  #l9.
    assert proof__uif__loop_invariant proof__uif__for_all {Index Lo_Index => 
        switch Lo_Index
          case (attribute__uif__first `X, Lo - 1ii) => proof__uif__for_all {Index Hi_Index => 
              switch Hi_Index
                case (attribute__uif__first `X, attribute__uif__last `X) => Max_Sum >= Sum (X, `Slice_Bounds {
                  __positional0 = Lo_Index,
                  __positional1 = Hi_Index
                })
                default => true}
          default => true};

  #l10.
    assert proof__uif__loop_invariant 
        if Result.Lo <= Result.Hi then attribute__uif__first `X <= Result.Lo &&& Result.Hi <= attribute__uif__last `X &&& Max_Sum == Sum (X, Result)
    ;

  #l12.
    _tcomp2 := attribute__uif__first `X;

  #l13.
    _tcomp3 := attribute__uif__last `X;

  #l14.
    if _tcomp2 > _tcomp3 then goto l11;

  #l15.
    Hi := _tcomp2;

  #l16.
    // empty loc

  #l17.
    assert proof__uif__loop_invariant proof__uif__for_all {Index Lo_Index => 
        switch Lo_Index
          case (attribute__uif__first `X, Lo - 1ii) => proof__uif__for_all {Index Hi_Index => 
              switch Hi_Index
                case (attribute__uif__first `X, attribute__uif__last `X) => Max_Sum >= Sum (X, `Slice_Bounds {
                  __positional0 = Lo_Index,
                  __positional1 = Hi_Index
                })
                default => true}
          default => true} && proof__uif__for_all {Index Hi_Index => 
        switch Hi_Index
          case (attribute__uif__first `X, Hi - 1ii) => Max_Sum >= Sum (X, `Slice_Bounds {
            __positional0 = Lo,
            __positional1 = Hi_Index
          })
          default => true};

  #l18.
    assert proof__uif__loop_invariant 
        if Result.Lo <= Result.Hi then attribute__uif__first `X <= Result.Lo &&& Result.Hi <= attribute__uif__last `X &&& Max_Sum == Sum (X, Result)
    ;

  #l19.
    Current_Slice := `Slice_Bounds {
      __positional0 = Lo,
      __positional1 = Hi
    };

  #l20.
    call _tcomp4 := Sum (X, Current_Slice);

  #l21.
    Current_Sum := _tcomp4;

  #l23.
    if !(Current_Sum > Max_Sum) then goto l22;

  #l24.
    Result := Current_Slice;

  #l25.
    Max_Sum := Current_Sum;

  #l22.
    // empty loc

  #l26.
    if Hi == _tcomp3 then goto l11;

  #l27.
    Hi := Hi + 1ii;

  #l28.
    goto l16;

  #l11.
    // empty loc

  #l29.
    if Lo == _tcomp1 then goto l3;

  #l30.
    Lo := Lo + 1ii;

  #l31.
    goto l8;

  #l3.
    // empty loc

  #l32.
    return Result;
}

procedure Slice_Bounds Maximal_Sum_Slice_Bounds_2 (
        Vector X) {
  local
    Natural Max_Sum;
    Integer Current_Sum;
    Index Current_Lo;
    Slice_Bounds Result;
    Index Current_Hi;
    Index _tcomp5;
    Index _tcomp6;


  #l33.
    Max_Sum := 0ii;

  #l34.
    Current_Sum := 0ii;

  #l37.
    if !(attribute__uif__first `X > attribute__uif__last `X) then goto l36;

  #l38.
    Result := `Slice_Bounds {
      Lo = 1ii,
      Hi = 0ii
    };

  #l39.
    goto l35;

  #l36.
    // empty loc

  #l40.
    Result := `Slice_Bounds {
      Lo = attribute__uif__first `X,
      Hi = 0ii
    };

  #l41.
    Current_Lo := Result.Lo;

  #l43.
    _tcomp5 := attribute__uif__first `X;

  #l44.
    _tcomp6 := attribute__uif__last `X;

  #l45.
    if _tcomp5 > _tcomp6 then goto l42;

  #l46.
    Current_Hi := _tcomp5;

  #l47.
    // empty loc

  #l48.
    assert proof__uif__loop_invariant attribute__uif__first `X <= Current_Lo &&& Current_Lo <= Current_Hi &&& 0ii <= Current_Sum &&& Current_Sum <= Current_Hi - Current_Lo * attribute__uif__last `Vector_Element;

  #l49.
    assert proof__uif__loop_invariant Current_Sum == Sum (X, `Slice_Bounds {
      __positional0 = Current_Lo,
      __positional1 = Current_Hi - 1ii
    });

  #l50.
    assert proof__uif__loop_invariant 
        if Result.Lo <= Result.Hi then attribute__uif__first `X <= Result.Lo &&& Result.Hi <= attribute__uif__last `X &&& Max_Sum == Sum (X, Result)
    ;

  #l51.
    assert proof__uif__loop_invariant proof__uif__for_all {Index Lo_Index => 
        switch Lo_Index
          case (attribute__uif__first `X, Current_Hi - 1ii) => proof__uif__for_all {Index Hi_Index => 
              switch Hi_Index
                case (attribute__uif__first `X, Current_Hi - 1ii) => Max_Sum >= Sum (X, `Slice_Bounds {
                  __positional0 = Lo_Index,
                  __positional1 = Hi_Index
                })
                default => true}
          default => true};

  #l52.
    assert proof__uif__loop_invariant proof__uif__for_all {Index Lo_Index => 
        switch Lo_Index
          case (attribute__uif__first `X, Current_Lo - 1ii) => Sum (X, `Slice_Bounds {
            __positional0 = Lo_Index,
            __positional1 = Current_Lo - 1ii
          }) <= 0ii
          default => true};

  #l53.
    assert proof__uif__loop_invariant proof__uif__for_all {Index Hi_Index => 
        switch Hi_Index
          case (Current_Lo, Current_Hi - 1ii) => Sum (X, `Slice_Bounds {
            __positional0 = Current_Lo,
            __positional1 = Hi_Index
          }) >= 0ii
          default => true};

  #l54.
    Current_Sum := Current_Sum + X[Current_Hi];

  #l57.
    if !(Current_Sum > Max_Sum) then goto l56;

  #l58.
    Max_Sum := Current_Sum;

  #l59.
    Result.Lo := Current_Lo;

  #l60.
    Result.Hi := Current_Hi;

  #l61.
    goto l55;

  #l56.
    // empty loc

  #l63.
    if !(Current_Sum < 0ii) then goto l62;

  #l65.
    if !(Current_Hi != attribute__uif__last `Index) then goto l64;

  #l66.
    Current_Lo := Current_Hi + 1ii;

  #l67.
    Current_Sum := 0ii;

  #l64.
    // empty loc

  #l68.
    goto l55;

  #l55.
    // empty loc

  #l69.
    if Current_Hi == _tcomp6 then goto l42;

  #l70.
    Current_Hi := Current_Hi + 1ii;

  #l71.
    goto l47;

  #l42.
    // empty loc

  #l35.
    // empty loc

  #l72.
    return Result;
}package Slice_Sums;


procedure Slice_Bounds Maximal_Sum_Slice_Bounds (
        Vector X) {

}

procedure Slice_Bounds Maximal_Sum_Slice_Bounds_2 (
        Vector X) {

}package Sums;


procedure Integer Sum (
        Vector X,
        Slice_Bounds Bounds) {
  local
    Integer Result;
    Index I;
    Index _tcomp7;
    Index _tcomp8;


  #l73.
    Result := 0ii;

  #l75.
    _tcomp7 := Bounds.Lo;

  #l76.
    _tcomp8 := Bounds.Hi;

  #l77.
    if _tcomp7 > _tcomp8 then goto l74;

  #l78.
    I := _tcomp7;

  #l79.
    // empty loc

  #l80.
    Result := Result + X[I];

  #l81.
    if I == _tcomp8 then goto l74;

  #l82.
    I := I + 1ii;

  #l83.
    goto l79;

  #l74.
    // empty loc

  #l84.
    return Result;
}package Sums;


typealias Integer Extended_Index;

typealias Integer Index;

typealias Integer Vector_Element;

typealias _UNCONSTRAINED_ARRAY_ Vector;

record Slice_Bounds {

  Index Lo;

  Extended_Index Hi;
}

procedure Integer Sum (
        Vector X,
        Slice_Bounds Bounds) {

}package Standard;


typealias Boolean Boolean;

typealias Integer Integer;

typealias Integer Natural;

typealias Integer Positive;

typealias Float Float;

typealias universal_integer universal_integer;

typealias universal_real universal_real;

typealias Character Character;

typealias String String;