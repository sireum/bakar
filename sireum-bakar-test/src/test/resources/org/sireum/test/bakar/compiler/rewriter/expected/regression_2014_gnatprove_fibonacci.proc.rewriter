package Fib;


procedure Natural Fibonacci (
        Natural n) {
  local
    Natural a;
    Natural b;
    Natural t;
    Natural i;
    Natural _tcomp0;
    Natural _tcomp1;


  #l1.
    a := 1ii;

  #l2.
    b := 1ii;

  #l4.
    _tcomp0 := 2ii;

  #l5.
    _tcomp1 := n;

  #l6.
    if _tcomp0 > _tcomp1 then goto l3;

  #l7.
    i := _tcomp0;

  #l8.
    // empty loc

  #l9.
    assert proof__uif__loop_invariant b <= a &&& a <= 2ii POWER i - 2ii;

  #l10.
    t := a;

  #l11.
    a := a + b;

  #l12.
    b := t;

  #l13.
    if i == _tcomp1 then goto l3;

  #l14.
    i := i + 1ii;

  #l15.
    goto l8;

  #l3.
    // empty loc

  #l16.
    return a;
}

procedure FibonacciSC (
        Natural n1,
        Natural n2,
        Natural l1,
        Natural l2) {
  local
    Natural a1;
    Natural a2;
    Natural b1;
    Natural b2;
    Natural i;
    Natural copy_n1;
    Natural copy_n2;


  #l17.
    copy_n1 := n1;

  #l18.
    copy_n2 := n2;

  #l19.
    a1 := 1ii;

  #l20.
    a2 := 1ii;

  #l21.
    b1 := 1ii;

  #l22.
    b2 := 1ii;

  #l23.
    i := 2ii;

  #l25.
    // empty loc

  #l26.
    if !(n1 > 2ii) then goto l24;

  #l27.
    assert proof__uif__loop_invariant a1 == Fibonacci (i) &&& b1 == Fibonacci (i - 1ii) &&& i <= 23ii &&& n1 + i - 2ii == copy_n1;

  #l28.
    assert proof__uif__loop_variant { decreases => n1};

  #l29.
    a1 := a1 + b1;

  #l30.
    b1 := a1 - b1;

  #l31.
    n1 := n1 - 1ii;

  #l32.
    i := i + 1ii;

  #l33.
    goto l25;

  #l24.
    // empty loc

  #l34.
    i := 2ii;

  #l36.
    // empty loc

  #l37.
    if !(n2 > 2ii) then goto l35;

  #l38.
    assert proof__uif__loop_invariant a2 == Fibonacci (i) &&& b2 == Fibonacci (i - 1ii) &&& i <= 23ii &&& n2 + i - 2ii == copy_n2;

  #l39.
    assert proof__uif__loop_variant { decreases => n2};

  #l40.
    a2 := a2 + b2;

  #l41.
    b2 := a2 - b2;

  #l42.
    n2 := n2 - 1ii;

  #l43.
    i := i + 1ii;

  #l44.
    goto l36;

  #l35.
    // empty loc

  #l47.
    if !(a1 > l1) then goto l46;

  #l48.
    l1 := a1;

  #l49.
    goto l45;

  #l46.
    // empty loc

  #l50.
    l1 := 0ii;

  #l45.
    // empty loc

  #l53.
    if !(a2 > l2) then goto l52;

  #l54.
    l2 := a2;

  #l55.
    goto l51;

  #l52.
    // empty loc

  #l56.
    l2 := 0ii;

  #l51.
    // empty loc

  #l57.
    return (n1, n2, l1, l2);
}

procedure Natural Factorial (
        Natural n) {
  local
    Natural p;
    Natural i;
    Natural _tcomp2;
    Natural _tcomp3;


  #l58.
    p := 1ii;

  #l60.
    _tcomp2 := 2ii;

  #l61.
    _tcomp3 := n;

  #l62.
    if _tcomp2 > _tcomp3 then goto l59;

  #l63.
    i := _tcomp2;

  #l64.
    // empty loc

  #l65.
    p := i * p;

  #l66.
    if i == _tcomp3 then goto l59;

  #l67.
    i := i + 1ii;

  #l68.
    goto l64;

  #l59.
    // empty loc

  #l69.
    return p;
}

procedure FactorialSC (
        Natural n1,
        Natural n2,
        Natural p1,
        Natural p2) {
  local
    Natural i;
    Natural _tcomp4;
    Natural _tcomp5;
    Natural i0;
    Natural _tcomp6;
    Natural _tcomp7;


  #l70.
    p1 := 1ii;

  #l72.
    _tcomp4 := 2ii;

  #l73.
    _tcomp5 := n1;

  #l74.
    if _tcomp4 > _tcomp5 then goto l71;

  #l75.
    i := _tcomp4;

  #l76.
    // empty loc

  #l77.
    assert proof__uif__loop_invariant p1 == Factorial (i - 1ii);

  #l78.
    p1 := i * p1;

  #l79.
    if i == _tcomp5 then goto l71;

  #l80.
    i := i + 1ii;

  #l81.
    goto l76;

  #l71.
    // empty loc

  #l82.
    p2 := 1ii;

  #l84.
    _tcomp6 := 2ii;

  #l85.
    _tcomp7 := n2;

  #l86.
    if _tcomp6 > _tcomp7 then goto l83;

  #l87.
    i0 := _tcomp6;

  #l88.
    // empty loc

  #l89.
    assert proof__uif__loop_invariant p2 == Factorial (i - 1ii);

  #l90.
    p2 := i * p2;

  #l91.
    if i0 == _tcomp7 then goto l83;

  #l92.
    i0 := i0 + 1ii;

  #l93.
    goto l88;

  #l83.
    // empty loc

  #l94.
    return (p1, p2);
}

procedure PowerSC (
        Integer a1,
        Integer a2,
        Natural n1,
        Natural n2,
        Integer p1,
        Integer p2) {
  local
    Integer b1;
    Integer b2;
    Natural k1;
    Natural k2;


  #l95.
    p1 := 1ii;

  #l96.
    b1 := a1;

  #l97.
    k1 := n1;

  #l99.
    // empty loc

  #l100.
    if !(k1 > 0ii) then goto l98;

  #l101.
    assert proof__uif__loop_invariant a1 POWER n1 == p1 * b1 POWER k1 &&& k1 >= 0ii;

  #l102.
    assert proof__uif__loop_variant { decreases => k1};

  #l105.
    if !(k1 % 2ii == 0ii) then goto l104;

  #l106.
    assert p1 * b1 * b1 POWER k1 MOD 2ii == a1 POWER n1;

  #l107.
    k1 := k1 MOD 2ii;

  #l108.
    b1 := b1 * b1;

  #l109.
    goto l103;

  #l104.
    // empty loc

  #l110.
    assert p1 * b1 * b1 POWER k1 - 1ii == a1 POWER n1;

  #l111.
    k1 := k1 - 1ii;

  #l112.
    p1 := b1 * p1;

  #l103.
    // empty loc

  #l113.
    goto l99;

  #l98.
    // empty loc

  #l114.
    p2 := 1ii;

  #l115.
    b2 := a2;

  #l116.
    k2 := n2;

  #l118.
    // empty loc

  #l119.
    if !(k2 > 0ii) then goto l117;

  #l120.
    assert proof__uif__loop_invariant a2 POWER n2 == p2 * b2 POWER k2 &&& k1 >= 0ii &&& p2 <= a2 POWER n2 &&& b2 <= a2 POWER n2;

  #l121.
    assert proof__uif__loop_variant { decreases => k2};

  #l124.
    if !(k2 % 2ii == 0ii) then goto l123;

  #l125.
    assert p2 * b2 * b2 POWER k2 MOD 2ii == a2 POWER n2;

  #l126.
    k2 := k2 MOD 2ii;

  #l127.
    b2 := b2 * b2;

  #l128.
    goto l122;

  #l123.
    // empty loc

  #l129.
    assert p2 * b2 * b2 POWER k2 - 1ii == a2 POWER n2 &&& k2 >= 1ii;

  #l130.
    k2 := k2 - 1ii;

  #l131.
    p2 := b2 * p2;

  #l122.
    // empty loc

  #l132.
    goto l118;

  #l117.
    // empty loc

  #l133.
    return (p1, p2);
}

procedure ArrayPartitionedTransferSC (
        IntArray A1,
        IntArray A2,
        IntArray B1,
        IntArray B2,
        IntArray C1,
        IntArray C2,
        Natural K1,
        Natural K2) {
  local
    Natural I;
    Natural _tcomp8;
    Natural _tcomp9;
    Natural I0;
    Natural _tcomp10;
    Natural _tcomp11;
    Natural I1;
    Natural _tcomp12;
    Natural _tcomp13;
    Natural I2;
    Natural _tcomp14;
    Natural _tcomp15;


  #l135.
    _tcomp8 := attribute__uif__first `A1;

  #l136.
    _tcomp9 := K1;

  #l137.
    if _tcomp8 > _tcomp9 then goto l134;

  #l138.
    I := _tcomp8;

  #l139.
    // empty loc

  #l140.
    A1[I] := B1[I];

  #l141.
    if I == _tcomp9 then goto l134;

  #l142.
    I := I + 1ii;

  #l143.
    goto l139;

  #l134.
    // empty loc

  #l145.
    _tcomp10 := K1 + 1ii;

  #l146.
    _tcomp11 := attribute__uif__first `A1;

  #l147.
    if _tcomp10 > _tcomp11 then goto l144;

  #l148.
    I0 := _tcomp10;

  #l149.
    // empty loc

  #l150.
    A1[I] := C1[I - K1];

  #l151.
    if I0 == _tcomp11 then goto l144;

  #l152.
    I0 := I0 + 1ii;

  #l153.
    goto l149;

  #l144.
    // empty loc

  #l155.
    _tcomp12 := attribute__uif__first `A2;

  #l156.
    _tcomp13 := K2;

  #l157.
    if _tcomp12 > _tcomp13 then goto l154;

  #l158.
    I1 := _tcomp12;

  #l159.
    // empty loc

  #l160.
    A2[I] := B2[I];

  #l161.
    if I1 == _tcomp13 then goto l154;

  #l162.
    I1 := I1 + 1ii;

  #l163.
    goto l159;

  #l154.
    // empty loc

  #l165.
    _tcomp14 := K2 + 1ii;

  #l166.
    _tcomp15 := attribute__uif__last `A2;

  #l167.
    if _tcomp14 > _tcomp15 then goto l164;

  #l168.
    I2 := _tcomp14;

  #l169.
    // empty loc

  #l170.
    A2[I] := C2[I - K2];

  #l171.
    if I2 == _tcomp15 then goto l164;

  #l172.
    I2 := I2 + 1ii;

  #l173.
    goto l169;

  #l164.
    // empty loc

  #l174.
    return (A1, A2);
}

procedure ArrayPartitionedTransferSIFL (
        IntArray A1,
        IntArray A2,
        IntArray B1,
        IntArray B2,
        IntArray C1,
        IntArray C2,
        Natural K) {
  local
    Natural I;
    Natural _tcomp16;
    Natural _tcomp17;
    Natural I0;
    Natural _tcomp18;
    Natural _tcomp19;
    Natural I1;
    Natural _tcomp20;
    Natural _tcomp21;
    Natural I2;
    Natural _tcomp22;
    Natural _tcomp23;


  #l176.
    _tcomp16 := attribute__uif__first `A1;

  #l177.
    _tcomp17 := K;

  #l178.
    if _tcomp16 > _tcomp17 then goto l175;

  #l179.
    I := _tcomp16;

  #l180.
    // empty loc

  #l181.
    A1[I] := B1[I];

  #l182.
    if I == _tcomp17 then goto l175;

  #l183.
    I := I + 1ii;

  #l184.
    goto l180;

  #l175.
    // empty loc

  #l186.
    _tcomp18 := K + 1ii;

  #l187.
    _tcomp19 := attribute__uif__last `A1;

  #l188.
    if _tcomp18 > _tcomp19 then goto l185;

  #l189.
    I0 := _tcomp18;

  #l190.
    // empty loc

  #l191.
    A1[I] := C1[I - K];

  #l192.
    if I0 == _tcomp19 then goto l185;

  #l193.
    I0 := I0 + 1ii;

  #l194.
    goto l190;

  #l185.
    // empty loc

  #l196.
    _tcomp20 := attribute__uif__first `A2;

  #l197.
    _tcomp21 := K;

  #l198.
    if _tcomp20 > _tcomp21 then goto l195;

  #l199.
    I1 := _tcomp20;

  #l200.
    // empty loc

  #l201.
    A2[I] := B2[I];

  #l202.
    if I1 == _tcomp21 then goto l195;

  #l203.
    I1 := I1 + 1ii;

  #l204.
    goto l200;

  #l195.
    // empty loc

  #l206.
    _tcomp22 := K + 1ii;

  #l207.
    _tcomp23 := attribute__uif__last `A2;

  #l208.
    if _tcomp22 > _tcomp23 then goto l205;

  #l209.
    I2 := _tcomp22;

  #l210.
    // empty loc

  #l211.
    A2[I] := C2[I - K];

  #l212.
    if I2 == _tcomp23 then goto l205;

  #l213.
    I2 := I2 + 1ii;

  #l214.
    goto l210;

  #l205.
    // empty loc

  #l215.
    return (A1, A2);
}package Fib;


typealias Integer anonymousType$0;

typealias _ARRAY_ IntArray;

procedure Natural Fibonacci (
        Natural n) {

}

procedure FibonacciSC (
        Natural n1,
        Natural n2,
        Natural l1,
        Natural l2) {

}

procedure Natural Factorial (
        Natural n) {

}

procedure FactorialSC (
        Natural n1,
        Natural n2,
        Natural p1,
        Natural p2) {

}

procedure PowerSC (
        Integer a1,
        Integer a2,
        Natural n1,
        Natural n2,
        Integer p1,
        Integer p2) {

}

procedure ArrayPartitionedTransferSC (
        IntArray A1,
        IntArray A2,
        IntArray B1,
        IntArray B2,
        IntArray C1,
        IntArray C2,
        Natural K1,
        Natural K2) {

}

procedure ArrayPartitionedTransferSIFL (
        IntArray A1,
        IntArray A2,
        IntArray B1,
        IntArray B2,
        IntArray C1,
        IntArray C2,
        Natural K) {

}package Standard;


typealias Boolean Boolean;

typealias Integer Integer;

typealias Integer Natural;

typealias Integer Positive;

typealias Float Float;

typealias universal_integer universal_integer;

typealias universal_real universal_real;

typealias Character Character;

typealias String String;