package __anonymousPackage$0;


procedure Main {
  local
    Integer X;
    Integer N;
    Positive I;
    Integer Result;
    Integer Result2;


  #l1.
    X := 2ii;

  #l2.
    N := 15ii;

  #l3.
    I := 1ii;

  #l5.
    // empty loc

  #l6.
    if !(I <= N) then goto l4;

  #l7.
    call Sum (I, Result);

  #l8.
    call Sum_Of_Sum (I, Result2);

  #l9.
    call Put_Line ("Sum(" STRING_CONCATENATE attribute__uif__iamge (`Integer, I) STRING_CONCATENATE " ) = " STRING_CONCATENATE attribute__uif__iamge (`Integer, Result));

  #l10.
    call Put_Line ("Sum_Of_Sum(" STRING_CONCATENATE attribute__uif__iamge (`Integer, I) STRING_CONCATENATE " ) = " STRING_CONCATENATE attribute__uif__iamge (`Integer, Result2));

  #l11.
    I := I + 1ii;

  #l12.
    goto l5;

  #l4.
    // empty loc

  #l13.
    return;
}package Power_and_Sum;


procedure Power (
        Integer X,
        Positive N,
        Integer Result) {
  local
    Integer I;


  #l14.
    I := 1ii;

  #l15.
    Result := X;

  #l17.
    // empty loc

  #l18.
    if !(I < N) then goto l16;

  #l19.
    assert proof__uif__loop_invariant Result == X POWER I &&& I >= 1ii;

  #l20.
    Result := Result * X;

  #l21.
    I := I + 1ii;

  #l22.
    goto l17;

  #l16.
    // empty loc

  #l23.
    return (Result);
}

procedure Sum (
        Positive N,
        Positive Result) {
  local
    Positive I;
    Natural TotalSum;


  #l24.
    I := 1ii;

  #l25.
    TotalSum := 0ii;

  #l27.
    // empty loc

  #l28.
    if !(I <= N) then goto l26;

  #l29.
    assert proof__uif__loop_invariant 2ii * TotalSum == I * I - 1ii;

  #l30.
    TotalSum := TotalSum + I;

  #l31.
    I := I + 1ii;

  #l32.
    goto l27;

  #l26.
    // empty loc

  #l33.
    assert 2ii * TotalSum == N * N + 1ii;

  #l34.
    Result := TotalSum;

  #l35.
    return (Result);
}

procedure Sum_Of_Sum (
        Positive N,
        Positive Result) {
  local
    Positive I;
    Positive J;
    Natural TotalSum;
    Natural InnerSum;


  #l36.
    I := 1ii;

  #l37.
    J := 1ii;

  #l38.
    TotalSum := 0ii;

  #l39.
    InnerSum := 0ii;

  #l41.
    // empty loc

  #l42.
    if !(I <= N) then goto l40;

  #l43.
    assert proof__uif__loop_invariant 6ii * TotalSum == I - 1ii * I * I + 1ii;

  #l44.
    InnerSum := 0ii;

  #l45.
    J := 1ii;

  #l47.
    // empty loc

  #l48.
    if !(J <= I) then goto l46;

  #l49.
    assert proof__uif__loop_invariant 2ii * InnerSum == J * J - 1ii;

  #l50.
    InnerSum := InnerSum + J;

  #l51.
    J := J + 1ii;

  #l52.
    goto l47;

  #l46.
    // empty loc

  #l53.
    assert J == I + 1ii;

  #l54.
    assert 2ii * InnerSum == I * I + 1ii;

  #l55.
    TotalSum := TotalSum + InnerSum;

  #l56.
    I := I + 1ii;

  #l57.
    goto l41;

  #l40.
    // empty loc

  #l58.
    assert 6ii * TotalSum == N * N + 1ii * N + 2ii;

  #l59.
    Result := TotalSum;

  #l60.
    return (Result);
}package Power_and_Sum;


procedure Power (
        Integer X,
        Positive N,
        Integer Result) {

}

procedure Sum (
        Positive N,
        Positive Result) {

}

procedure Sum_Of_Sum (
        Positive N,
        Positive Result) {

}package Standard;


typealias Boolean Boolean;

typealias Integer Integer;

typealias Integer Natural;

typealias Integer Positive;

typealias Float Float;

typealias universal_integer universal_integer;

typealias universal_real universal_real;

typealias Character Character;

typealias String String;