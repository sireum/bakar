package Queen;


procedure Add_next (
        Board B,
        Index I,
        Boolean Done,
        Board C) {
  local
    Boolean _tcomp0;
    Boolean _tbpr3;
    Board _tbpr1;


  #l3.
    call _tcomp0 := Consistent (B, I);

  #l4.
    if !(_tcomp0) then goto l2;

  #l7.
    if !(N == I) then goto l6;

  #l8.
    Done := true;

  #l9.
    goto l5;

  #l6.
    // empty loc

  #l10.
    call _tbpr1, _tbpr3 := Try_Row (B, I + 1ii, Done, C);

  #_lbpr2.
    B := _tbpr1;

  #_lbpr4.
    Done := _tbpr3;

  #l5.
    // empty loc

  #l11.
    return;

  #l12.
    goto l1;

  #l2.
    // empty loc

  #l13.
    assert !(Consistent (C, I));

  #l14.
    assert !(proof__uif__for_all {universal_integer J => 
        switch J
          case (I, N) => Consistent (C, J)
          default => true});

  #l1.
    // empty loc

  #l15.
    return (B, Done);
}

procedure Board Copy_Until (
        Board B,
        Index I,
        Board C) {
  local
    Board R;
    universal_integer J;
    universal_integer _tcomp1;
    universal_integer _tcomp2;
    universal_integer J0;
    universal_integer _tcomp3;
    universal_integer _tcomp4;


  #l16.
    R := { iter => 
        switch iter
          case (attribute__uif__first Index, attribute__uif__last Index) => 1ii
    };

  #l18.
    _tcomp1 := attribute__uif__first `Index;

  #l19.
    _tcomp2 := I;

  #l20.
    if _tcomp1 > _tcomp2 then goto l17;

  #l21.
    J := _tcomp1;

  #l22.
    // empty loc

  #l23.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer K => 
        switch K
          case (attribute__uif__first `Index, J - 1ii) => R[K] == B[K]
          default => true};

  #l24.
    R[J] := B[J];

  #l25.
    if J == _tcomp2 then goto l17;

  #l26.
    J := J + 1ii;

  #l27.
    goto l22;

  #l17.
    // empty loc

  #l29.
    _tcomp3 := I + 1ii;

  #l30.
    _tcomp4 := attribute__uif__last `Index;

  #l31.
    if _tcomp3 > _tcomp4 then goto l28;

  #l32.
    J0 := _tcomp3;

  #l33.
    // empty loc

  #l34.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer K => 
        switch K
          case (attribute__uif__first `Index, I) => R[K] == B[K]
          default => true};

  #l35.
    R[J] := C[J];

  #l36.
    if J0 == _tcomp4 then goto l28;

  #l37.
    J0 := J0 + 1ii;

  #l38.
    goto l33;

  #l28.
    // empty loc

  #l39.
    return R;
}

procedure Try_Row (
        Board B,
        Index I,
        Boolean Done,
        Board C) {
  local
    universal_integer R;
    universal_integer _tcomp5;
    universal_integer _tcomp6;
    Board _tcomp7;
    Boolean _tbpr7;
    Board _tbpr5;
    Boolean _tbpr3;
    Board _tbpr1;


  #l41.
    _tcomp5 := attribute__uif__first (Index);

  #l42.
    _tcomp6 := attribute__uif__last (Index);

  #l43.
    if _tcomp5 > _tcomp6 then goto l40;

  #l44.
    R := _tcomp5;

  #l45.
    // empty loc

  #l46.
    assert proof__uif__loop_invariant !(Done) && proof__uif__for_all {universal_integer J => 
        switch J
          case (1ii, I - 1ii) => B[J] == attribute__uif__loop_entry B[J]
          default => true} && 
        if C[I] < R then !(Consistent (C, N))
    ;

  #l47.
    B[I] := R;

  #l50.
    if !(C[I] == R) then goto l49;

  #l51.
    call _tbpr1, _tbpr3 := Add_next (B, I, Done, C);

  #_lbpr2.
    B := _tbpr1;

  #_lbpr4.
    Done := _tbpr3;

  #l52.
    goto l48;

  #l49.
    // empty loc

  #l53.
    call _tcomp7 := Copy_Until (B, I, C);

  #l54.
    call _tbpr5, _tbpr7 := Add_next (B, I, Done, _tcomp7);

  #_lbpr6.
    B := _tbpr5;

  #_lbpr8.
    Done := _tbpr7;

  #l48.
    // empty loc

  #l56.
    if !(Done) then goto l55;

  #l57.
    goto l40;

  #l55.
    // empty loc

  #l58.
    if R == _tcomp6 then goto l40;

  #l59.
    R := R + 1ii;

  #l60.
    goto l45;

  #l40.
    // empty loc

  #l61.
    return (B, Done);
}package Queen;


typealias Positive Index;

typealias _ARRAY_ Board;

const $CONST {
  N = (Positive) 8ii;
}

procedure Boolean Consistent_Index (
        Board B,
        Index I1,
        Index I2) {

  #l62.
    return B[I1] != B[I2] &&& I1 - I2 != B[I1] - B[I2] &&& I1 - I2 != B[I2] - B[I1];
}

procedure Boolean Consistent (
        Board B,
        Index K) {

  #l63.
    return proof__uif__for_all {universal_integer I => 
        switch I
          case (attribute__uif__first `Index, K) => proof__uif__for_all {universal_integer J => 
              switch J
                case (attribute__uif__first `Index, I - 1ii) => B[I] != B[J] &&& I - J != B[I] - B[J] &&& I - J != B[J] - B[I]
                default => true}
          default => true};
}

procedure Add_next (
        Board B,
        Index I,
        Boolean Done,
        Board C) {

}

procedure Board Copy_Until (
        Board B,
        Index I,
        Board C) {

}

procedure Try_Row (
        Board B,
        Index I,
        Boolean Done,
        Board C) {

}package Standard;


typealias Boolean Boolean;

typealias Integer Integer;

typealias Integer Natural;

typealias Integer Positive;

typealias Float Float;

typealias universal_integer universal_integer;

typealias universal_real universal_real;

typealias Character Character;

typealias String String;