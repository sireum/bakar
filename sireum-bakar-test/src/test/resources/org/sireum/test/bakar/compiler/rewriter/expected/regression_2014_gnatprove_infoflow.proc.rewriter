package Infoflow;


procedure Machine_Step {
  local
    Character Data_0_V1;
    Character Data_1_V1;
    Character Data_0_V2;
    Character Data_1_V2;


  #l2.
    if !(@@In_0_Rdy_V1 && !(@@Out_1_Rdy_V1)) then goto l1;

  #l3.
    Data_0_V1 := @@In_0_Dat_V1;

  #l4.
    @@In_0_Rdy_V1 := false;

  #l5.
    @@Out_1_Dat_V1 := Data_0_V1;

  #l6.
    @@Out_1_Rdy_V1 := true;

  #l1.
    // empty loc

  #l8.
    if !(@@In_1_Rdy_V1 && !(@@Out_0_Rdy_V1)) then goto l7;

  #l9.
    Data_1_V1 := @@In_1_Dat_V1;

  #l10.
    @@In_1_Rdy_V1 := false;

  #l11.
    @@Out_0_Dat_V1 := Data_1_V1;

  #l12.
    @@Out_0_Rdy_V1 := true;

  #l7.
    // empty loc

  #l14.
    if !(@@In_0_Rdy_V2 && !(@@Out_1_Rdy_V2)) then goto l13;

  #l15.
    Data_0_V2 := @@In_0_Dat_V2;

  #l16.
    @@In_0_Rdy_V2 := false;

  #l17.
    @@Out_1_Dat_V2 := Data_0_V2;

  #l18.
    @@Out_1_Rdy_V2 := true;

  #l13.
    // empty loc

  #l20.
    if !(@@In_1_Rdy_V2 && !(@@Out_0_Rdy_V2)) then goto l19;

  #l21.
    Data_1_V2 := @@In_1_Dat_V2;

  #l22.
    @@In_1_Rdy_V2 := false;

  #l23.
    @@Out_0_Dat_V2 := Data_1_V2;

  #l24.
    @@Out_0_Rdy_V2 := true;

  #l19.
    // empty loc

  #l25.
    return;
}

procedure SinglePositionAssign (
        Int Flag,
        FlagValue Value) {

  #l26.
    @@Flags[Flag] := Value;

  #l27.
    return;
}

procedure SinglePositionAssign (
        Int Flag_V1,
        Int Flag_V2,
        FlagValue Value_V1,
        FlagValue Value_V2) {

  #l28.
    @@Flags_V1[Flag_V1] := Value_V1;

  #l29.
    @@Flags_V2[Flag_V2] := Value_V2;

  #l30.
    return;
}

procedure ScrubCache (
        SensorCacheType Cache_V1,
        SensorCacheType Cache_V2) {
  local
    SensorIds I;
    SensorIds _tcomp0;
    SensorIds _tcomp1;
    SensorIds I0;
    SensorIds _tcomp2;
    SensorIds _tcomp3;


  #l32.
    _tcomp0 := attribute__uif__first `SensorIds;

  #l33.
    _tcomp1 := attribute__uif__last `SensorIds;

  #l34.
    if _tcomp0 > _tcomp1 then goto l31;

  #l35.
    I := _tcomp0;

  #l36.
    // empty loc

  #l37.
    Cache_V1[I] := 0ii;

  #l38.
    assert proof__uif__loop_invariant proof__uif__for_all {SensorIds K => 
        switch K
          case (attribute__uif__first `SensorIds, attribute__uif__last `SensorIds) => 
              if K <= I then Cache_V1[K] == 0ii

          default => true};

  #l39.
    if I == _tcomp1 then goto l31;

  #l40.
    I := I + 1ii;

  #l41.
    goto l36;

  #l31.
    // empty loc

  #l43.
    _tcomp2 := attribute__uif__first `SensorIds;

  #l44.
    _tcomp3 := attribute__uif__last `SensorIds;

  #l45.
    if _tcomp2 > _tcomp3 then goto l42;

  #l46.
    I0 := _tcomp2;

  #l47.
    // empty loc

  #l48.
    Cache_V2[I] := 0ii;

  #l49.
    assert proof__uif__loop_invariant proof__uif__for_all {SensorIds K => 
        switch K
          case (attribute__uif__first `SensorIds, attribute__uif__last `SensorIds) => 
              if K <= I then Cache_V2[K] == 0ii

          default => true};

  #l50.
    if I0 == _tcomp3 then goto l42;

  #l51.
    I0 := I0 + 1ii;

  #l52.
    goto l47;

  #l42.
    // empty loc

  #l53.
    return (Cache_V1, Cache_V2);
}

procedure CopyKeys (
        KeyTableType InKeys_V1,
        KeyTableType InKeys_V2,
        KeyTableType OutKeys_V1,
        KeyTableType OutKeys_V2,
        KeyTableEntries J) {
  local
    KeyTableEntries I;
    KeyTableEntries _tcomp4;
    KeyTableEntries _tcomp5;
    KeyTableEntries I0;
    KeyTableEntries _tcomp6;
    KeyTableEntries _tcomp7;


  #l55.
    _tcomp4 := attribute__uif__first `KeyTableEntries;

  #l56.
    _tcomp5 := attribute__uif__last `KeyTableEntries;

  #l57.
    if _tcomp4 > _tcomp5 then goto l54;

  #l58.
    I := _tcomp4;

  #l59.
    // empty loc

  #l60.
    OutKeys_V1[I] := InKeys_V1[I];

  #l61.
    assert proof__uif__loop_invariant proof__uif__for_all {KeyTableEntries K => 
        switch K
          case (attribute__uif__first `KeyTableEntries, attribute__uif__last `KeyTableEntries) => 
              if K <= I then OutKeys_V1[K] == InKeys_V1[K]

          default => true};

  #l62.
    if I == _tcomp5 then goto l54;

  #l63.
    I := I + 1ii;

  #l64.
    goto l59;

  #l54.
    // empty loc

  #l66.
    _tcomp6 := attribute__uif__first `KeyTableEntries;

  #l67.
    _tcomp7 := attribute__uif__last `KeyTableEntries;

  #l68.
    if _tcomp6 > _tcomp7 then goto l65;

  #l69.
    I0 := _tcomp6;

  #l70.
    // empty loc

  #l71.
    OutKeys_V2[I] := InKeys_V2[I];

  #l72.
    assert proof__uif__loop_invariant proof__uif__for_all {KeyTableEntries K => 
        switch K
          case (attribute__uif__first `KeyTableEntries, attribute__uif__last `KeyTableEntries) => 
              if K <= I then OutKeys_V2[K] == InKeys_V2[K]

          default => true};

  #l73.
    if I0 == _tcomp7 then goto l65;

  #l74.
    I0 := I0 + 1ii;

  #l75.
    goto l70;

  #l65.
    // empty loc

  #l76.
    return (OutKeys_V1, OutKeys_V2);
}

procedure FlipHalves (
        H_Type H_V1,
        H_Type H_V2,
        Integer I) {
  local
    Content T_V1;
    Integer M_V1;
    universal_integer Q_V1;
    universal_integer _tcomp8;
    universal_integer _tcomp9;
    Content T_V2;
    Integer M_V2;
    universal_integer Q_V2;
    universal_integer _tcomp10;
    universal_integer _tcomp11;


  #l77.
    M_V1 := attribute__uif__last `H_V1 / 2ii;

  #l79.
    _tcomp8 := attribute__uif__first `H_V1;

  #l80.
    _tcomp9 := M_V1;

  #l81.
    if _tcomp8 > _tcomp9 then goto l78;

  #l82.
    Q_V1 := _tcomp8;

  #l83.
    // empty loc

  #l84.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer K => 
        switch K
          case (attribute__uif__first (H_V1), attribute__uif__last (H_V1)) => 
              if K < Q_V1 then H_V1[K] == attribute__uif__loop_entry H_V1[K + M_V1]
              else if K > Q_V1 + M_V1 then H_V1[K] == attribute__uif__loop_entry H_V1[K - M_V1]
              else H_V1[K] == attribute__uif__loop_entry H_V1[K]
          default => true};

  #l85.
    T_V1 := H_V1[Q_V1];

  #l86.
    H_V1[Q_V1] := H_V1[Q_V1 + M_V1];

  #l87.
    H_V1[Q_V1 + M_V1] := T_V1;

  #l88.
    if Q_V1 == _tcomp9 then goto l78;

  #l89.
    Q_V1 := Q_V1 + 1ii;

  #l90.
    goto l83;

  #l78.
    // empty loc

  #l91.
    assert proof__uif__assert_and_cut true;

  #l92.
    M_V2 := attribute__uif__last `H_V2 / 2ii;

  #l94.
    _tcomp10 := attribute__uif__first `H_V2;

  #l95.
    _tcomp11 := M_V2;

  #l96.
    if _tcomp10 > _tcomp11 then goto l93;

  #l97.
    Q_V2 := _tcomp10;

  #l98.
    // empty loc

  #l99.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer K => 
        switch K
          case (attribute__uif__first (H_V2), attribute__uif__last (H_V2)) => 
              if K < Q_V2 then H_V2[K] == attribute__uif__loop_entry H_V2[K + M_V2]
              else if K > Q_V2 + M_V2 then H_V2[K] == attribute__uif__loop_entry H_V2[K - M_V2]
              else H_V2[K] == attribute__uif__loop_entry H_V2[K]
          default => true};

  #l100.
    T_V2 := H_V2[Q_V2];

  #l101.
    H_V2[Q_V2] := H_V2[Q_V2 + M_V2];

  #l102.
    H_V2[Q_V2 + M_V2] := T_V2;

  #l103.
    if Q_V2 == _tcomp11 then goto l93;

  #l104.
    Q_V2 := Q_V2 + 1ii;

  #l105.
    goto l98;

  #l93.
    // empty loc

  #l106.
    return (H_V1, H_V2);
}

procedure Flip (
        H_Type H) {

}

procedure Flip (
        H_Type H) {
  local
    Content T;
    Integer M;
    universal_integer Q;
    universal_integer _tcomp12;
    universal_integer _tcomp13;


  #l107.
    M := attribute__uif__last `H / 2ii;

  #l109.
    _tcomp12 := attribute__uif__first `H;

  #l110.
    _tcomp13 := M;

  #l111.
    if _tcomp12 > _tcomp13 then goto l108;

  #l112.
    Q := _tcomp12;

  #l113.
    // empty loc

  #l114.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer K => 
        switch K
          case (attribute__uif__first (H), attribute__uif__last (H)) => 
              if K < Q then H[K] == attribute__uif__loop_entry H[K + M]
              else if K > Q + M then H[K] == attribute__uif__loop_entry H[K - M]
              else H[K] == attribute__uif__loop_entry H[K]
          default => true};

  #l115.
    T := H[Q];

  #l116.
    H[Q] := H[Q + M];

  #l117.
    H[Q + M] := T;

  #l118.
    if Q == _tcomp13 then goto l108;

  #l119.
    Q := Q + 1ii;

  #l120.
    goto l113;

  #l108.
    // empty loc

  #l121.
    return (H);
}

procedure FlipHalves2 (
        H_Type H_V1,
        H_Type H_V2,
        Integer I) {
  local
    H_Type _tbpr3;
    H_Type _tbpr1;


  #l122.
    call _tbpr1 := Flip (H_V1);

  #_lbpr2.
    H_V1 := _tbpr1;

  #l123.
    call _tbpr3 := Flip (H_V2);

  #_lbpr4.
    H_V2 := _tbpr3;

  #l124.
    return (H_V1, H_V2);
}

procedure ArrayPartitionedTransfer (
        Arr A_V1,
        Arr A_V2,
        Arr B_V1,
        Arr C_V1,
        Arr B_V2,
        Arr C_V2,
        Integer K_1,
        Integer K_2,
        Integer I) {
  local
    universal_integer I_V1;
    universal_integer _tcomp14;
    universal_integer _tcomp15;
    universal_integer I_V10;
    universal_integer _tcomp16;
    universal_integer _tcomp17;
    universal_integer I_V2;
    universal_integer _tcomp18;
    universal_integer _tcomp19;
    universal_integer I_V20;
    universal_integer _tcomp20;
    universal_integer _tcomp21;


  #l126.
    _tcomp14 := attribute__uif__first `A_V1;

  #l127.
    _tcomp15 := K_1;

  #l128.
    if _tcomp14 > _tcomp15 then goto l125;

  #l129.
    I_V1 := _tcomp14;

  #l130.
    // empty loc

  #l131.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer M => 
        switch M
          case (attribute__uif__first `A_V1, I_V1 - 1ii) => A_V1[M] == B_V1[M]
          default => true};

  #l132.
    A_V1[I_V1] := B_V1[I_V1];

  #l133.
    if I_V1 == _tcomp15 then goto l125;

  #l134.
    I_V1 := I_V1 + 1ii;

  #l135.
    goto l130;

  #l125.
    // empty loc

  #l136.
    assert proof__uif__assert_and_cut proof__uif__for_all {universal_integer M => 
        switch M
          case (attribute__uif__first `A_V1, K_1) => A_V1[M] == B_V1[M]
          default => true};

  #l138.
    _tcomp16 := K_1 + 1ii;

  #l139.
    _tcomp17 := attribute__uif__last `A_V1;

  #l140.
    if _tcomp16 > _tcomp17 then goto l137;

  #l141.
    I_V10 := _tcomp16;

  #l142.
    // empty loc

  #l143.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer M => 
        switch M
          case (attribute__uif__first `A_V1, K_1) => A_V1[M] == B_V1[M]
          default => true} &&& proof__uif__for_all {universal_integer M => 
        switch M
          case (K_1 + 1ii, I_V1 - 1ii) => A_V1[M] == C_V1[M - K_1]
          default => true};

  #l144.
    A_V1[I_V1] := C_V1[I_V1 - K_1];

  #l145.
    if I_V10 == _tcomp17 then goto l137;

  #l146.
    I_V10 := I_V10 + 1ii;

  #l147.
    goto l142;

  #l137.
    // empty loc

  #l148.
    assert proof__uif__assert_and_cut proof__uif__for_all {universal_integer M => 
        switch M
          case (attribute__uif__first `A_V1, K_1) => A_V1[M] == B_V1[M]
          default => true} &&& proof__uif__for_all {universal_integer M => 
        switch M
          case (K_1 + 1ii, attribute__uif__last `A_V1) => A_V1[M] == C_V1[M - K_1]
          default => true};

  #l150.
    _tcomp18 := attribute__uif__first `A_V2;

  #l151.
    _tcomp19 := K_2;

  #l152.
    if _tcomp18 > _tcomp19 then goto l149;

  #l153.
    I_V2 := _tcomp18;

  #l154.
    // empty loc

  #l155.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer M => 
        switch M
          case (attribute__uif__first `A_V2, I_V2 - 1ii) => A_V2[M] == B_V2[M]
          default => true};

  #l156.
    A_V2[I_V2] := B_V2[I_V2];

  #l157.
    if I_V2 == _tcomp19 then goto l149;

  #l158.
    I_V2 := I_V2 + 1ii;

  #l159.
    goto l154;

  #l149.
    // empty loc

  #l160.
    assert proof__uif__assert_and_cut proof__uif__for_all {universal_integer M => 
        switch M
          case (attribute__uif__first `A_V1, K_1) => A_V1[M] == B_V1[M]
          default => true} &&& proof__uif__for_all {universal_integer M => 
        switch M
          case (K_1 + 1ii, attribute__uif__last `A_V1) => A_V1[M] == C_V1[M - K_1]
          default => true} &&& proof__uif__for_all {universal_integer M => 
        switch M
          case (attribute__uif__first `A_V2, K_2) => A_V2[M] == B_V2[M]
          default => true};

  #l162.
    _tcomp20 := K_2 + 1ii;

  #l163.
    _tcomp21 := attribute__uif__last `A_V2;

  #l164.
    if _tcomp20 > _tcomp21 then goto l161;

  #l165.
    I_V20 := _tcomp20;

  #l166.
    // empty loc

  #l167.
    assert proof__uif__loop_invariant proof__uif__for_all {universal_integer M => 
        switch M
          case (attribute__uif__first `A_V2, K_2) => A_V2[M] == B_V2[M]
          default => true} &&& proof__uif__for_all {universal_integer M => 
        switch M
          case (K_2 + 1ii, I_V2 - 1ii) => A_V2[M] == C_V2[M - K_2]
          default => true};

  #l168.
    A_V2[I_V2] := C_V2[I_V2 - K_2];

  #l169.
    if I_V20 == _tcomp21 then goto l161;

  #l170.
    I_V20 := I_V20 + 1ii;

  #l171.
    goto l166;

  #l161.
    // empty loc

  #l172.
    return (A_V1, A_V2);
}package Infoflow;


typealias _SIGNED_INTEGER_TYPE_ Int;

typealias _ENUMERATION_TYPE_ FlagValue;

typealias _ARRAY_ FlagArray;

typealias _SIGNED_INTEGER_TYPE_ SensorIds;

typealias _ARRAY_ SensorCacheType;

typealias _SIGNED_INTEGER_TYPE_ KeyTableEntries;

typealias _ARRAY_ KeyTableType;

typealias _DERIVED_TYPE_ Content;

typealias _UNCONSTRAINED_ARRAY_ H_Type;

typealias _UNCONSTRAINED_ARRAY_ Arr;

global Boolean @@In_0_Rdy_V1;

global Boolean @@In_1_Rdy_V1;

global Boolean @@Out_0_Rdy_V1;

global Boolean @@Out_1_Rdy_V1;

global Character @@In_0_Dat_V1;

global Character @@In_1_Dat_V1;

global Character @@Out_0_Dat_V1;

global Character @@Out_1_Dat_V1;

global Boolean @@In_0_Rdy_V2;

global Boolean @@In_1_Rdy_V2;

global Boolean @@Out_0_Rdy_V2;

global Boolean @@Out_1_Rdy_V2;

global Character @@In_0_Dat_V2;

global Character @@In_1_Dat_V2;

global Character @@Out_0_Dat_V2;

global Character @@Out_1_Dat_V2;

global FlagArray @@Flags;

global FlagArray @@Flags_V1;

global FlagArray @@Flags_V2;

procedure Machine_Step {

}

procedure SinglePositionAssign (
        Int Flag,
        FlagValue Value) {

}

procedure SinglePositionAssign (
        Int Flag_V1,
        Int Flag_V2,
        FlagValue Value_V1,
        FlagValue Value_V2) {

}

procedure ScrubCache (
        SensorCacheType Cache_V1,
        SensorCacheType Cache_V2) {

}

procedure CopyKeys (
        KeyTableType InKeys_V1,
        KeyTableType InKeys_V2,
        KeyTableType OutKeys_V1,
        KeyTableType OutKeys_V2,
        KeyTableEntries J) {

}

procedure FlipHalves (
        H_Type H_V1,
        H_Type H_V2,
        Integer I) {

}

procedure FlipHalves2 (
        H_Type H_V1,
        H_Type H_V2,
        Integer I) {

}

procedure ArrayPartitionedTransfer (
        Arr A_V1,
        Arr A_V2,
        Arr B_V1,
        Arr C_V1,
        Arr B_V2,
        Arr C_V2,
        Integer K_1,
        Integer K_2,
        Integer I) {

}package Standard;


typealias Boolean Boolean;

typealias Integer Integer;

typealias Integer Natural;

typealias Integer Positive;

typealias Float Float;

typealias universal_integer universal_integer;

typealias universal_real universal_real;

typealias Character Character;

typealias String String;