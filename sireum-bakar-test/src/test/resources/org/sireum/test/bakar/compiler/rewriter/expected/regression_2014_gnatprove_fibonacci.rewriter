package Fib;


procedure Natural Fibonacci (
        Natural n) {
  local
    Natural a;
    Natural b;
    Natural t;
    Natural i;
    Natural _tcomp0;
    Natural _tcomp1;
    FIXME _t0;
    FIXME _t1;
    FIXME _t2;
    FIXME _t3;
    FIXME _t4;
    FIXME _t5;
    FIXME _t6;
    FIXME _t7;
    FIXME _t8;
    FIXME _t9;
    FIXME _t10;
    FIXME _t11;
    FIXME _t12;
    FIXME _t13;
    FIXME _t14;
    FIXME _t15;
    FIXME _t16;
    FIXME _t17;


  #l1.
    a := 1ii;

  #l2.
    b := 1ii;

  #l4.
    _tcomp0 := 2ii;

  #l5.
    _tcomp1 := n;

  #rwl0.
    _t0 := _tcomp0;

  #rwl1.
    _t1 := _tcomp1;

  #l6.
    if _t0 > _t1 then goto l3;

  #l7.
    i := _tcomp0;

  #l8.
    // empty loc

  #rwl2.
    _t2 := b;

  #rwl3.
    _t3 := a;

  #rwl4.
    _t4 := i;

  #rwl5.
    _t5 := 2ii;

  #rwl6.
    _t6 := 2ii;

  #rwl7.
    _t7 := _t4 - _t5;

  #rwl8.
    _t8 := a;

  #rwl9.
    _t9 := _t6 POWER _t7;

  #rwl10.
    _t10 := _t2 <= _t3;

  #rwl11.
    _t11 := _t8 <= _t9;

  #l9.
    assert proof__uif__loop_invariant _t10 &&& _t11;

  #l10.
    t := a;

  #rwl12.
    _t12 := a;

  #rwl13.
    _t13 := b;

  #l11.
    a := _t12 + _t13;

  #l12.
    b := t;

  #rwl14.
    _t14 := i;

  #rwl15.
    _t15 := _tcomp1;

  #l13.
    if _t14 == _t15 then goto l3;

  #rwl16.
    _t16 := i;

  #rwl17.
    _t17 := 1ii;

  #l14.
    i := _t16 + _t17;

  #l15.
    goto l8;

  #l3.
    // empty loc

  #l16.
    return a;
}

procedure FibonacciSC (
        Natural n1,
        Natural n2,
        Natural l1,
        Natural l2) {
  local
    Natural a1;
    Natural a2;
    Natural b1;
    Natural b2;
    Natural i;
    Natural copy_n1;
    Natural copy_n2;
    FIXME _t18;
    FIXME _t19;
    FIXME _t20;
    FIXME _t21;
    FIXME _t22;
    FIXME _t23;
    FIXME _t24;
    FIXME _t25;
    FIXME _t26;
    FIXME _t27;
    FIXME _t28;
    FIXME _t29;
    FIXME _t30;
    FIXME _t31;
    FIXME _t32;
    FIXME _t33;
    FIXME _t34;
    FIXME _t35;
    FIXME _t36;
    FIXME _t37;
    FIXME _t38;
    FIXME _t39;
    FIXME _t40;
    FIXME _t41;
    FIXME _t42;
    FIXME _t43;
    FIXME _t44;
    FIXME _t45;
    FIXME _t46;
    FIXME _t47;
    FIXME _t48;
    FIXME _t49;
    FIXME _t50;
    FIXME _t51;
    FIXME _t52;
    FIXME _t53;
    FIXME _t54;
    FIXME _t55;
    FIXME _t56;
    FIXME _t57;
    FIXME _t58;
    FIXME _t59;
    FIXME _t60;
    FIXME _t61;
    FIXME _t62;
    FIXME _t63;
    FIXME _t64;
    FIXME _t65;
    FIXME _t66;
    FIXME _t67;
    FIXME _t68;
    FIXME _t69;
    FIXME _t70;
    FIXME _t71;
    FIXME _t72;
    FIXME _t73;
    FIXME _t74;
    FIXME _t75;
    FIXME _t76;
    FIXME _t77;
    FIXME _t78;
    FIXME _t79;
    FIXME _t80;
    FIXME _t81;


  #l17.
    copy_n1 := n1;

  #l18.
    copy_n2 := n2;

  #l19.
    a1 := 1ii;

  #l20.
    a2 := 1ii;

  #l21.
    b1 := 1ii;

  #l22.
    b2 := 1ii;

  #l23.
    i := 2ii;

  #l25.
    // empty loc

  #rwl18.
    _t18 := n1;

  #rwl19.
    _t19 := 2ii;

  #l26.
    if !(_t18 > _t19) then goto l24;

  #rwl20.
    _t20 := a1;

  #rwl21.
    _t21 := Fibonacci (i);

  #rwl22.
    _t22 := i;

  #rwl23.
    _t23 := 1ii;

  #rwl24.
    _t24 := b1;

  #rwl25.
    _t25 := Fibonacci (_t22 - _t23);

  #rwl26.
    _t26 := _t20 == _t21;

  #rwl27.
    _t27 := _t24 == _t25;

  #rwl28.
    _t28 := i;

  #rwl29.
    _t29 := 23ii;

  #rwl30.
    _t30 := _t26 &&& _t27;

  #rwl31.
    _t31 := _t28 <= _t29;

  #rwl32.
    _t32 := n1;

  #rwl33.
    _t33 := i;

  #rwl34.
    _t34 := _t32 + _t33;

  #rwl35.
    _t35 := 2ii;

  #rwl36.
    _t36 := _t34 - _t35;

  #rwl37.
    _t37 := copy_n1;

  #rwl38.
    _t38 := _t30 &&& _t31;

  #rwl39.
    _t39 := _t36 == _t37;

  #l27.
    assert proof__uif__loop_invariant _t38 &&& _t39;

  #l28.
    assert proof__uif__loop_variant { decreases => n1};

  #rwl40.
    _t40 := a1;

  #rwl41.
    _t41 := b1;

  #l29.
    a1 := _t40 + _t41;

  #rwl42.
    _t42 := a1;

  #rwl43.
    _t43 := b1;

  #l30.
    b1 := _t42 - _t43;

  #rwl44.
    _t44 := n1;

  #rwl45.
    _t45 := 1ii;

  #l31.
    n1 := _t44 - _t45;

  #rwl46.
    _t46 := i;

  #rwl47.
    _t47 := 1ii;

  #l32.
    i := _t46 + _t47;

  #l33.
    goto l25;

  #l24.
    // empty loc

  #l34.
    i := 2ii;

  #l36.
    // empty loc

  #rwl48.
    _t48 := n2;

  #rwl49.
    _t49 := 2ii;

  #l37.
    if !(_t48 > _t49) then goto l35;

  #rwl50.
    _t50 := a2;

  #rwl51.
    _t51 := Fibonacci (i);

  #rwl52.
    _t52 := i;

  #rwl53.
    _t53 := 1ii;

  #rwl54.
    _t54 := b2;

  #rwl55.
    _t55 := Fibonacci (_t52 - _t53);

  #rwl56.
    _t56 := _t50 == _t51;

  #rwl57.
    _t57 := _t54 == _t55;

  #rwl58.
    _t58 := i;

  #rwl59.
    _t59 := 23ii;

  #rwl60.
    _t60 := _t56 &&& _t57;

  #rwl61.
    _t61 := _t58 <= _t59;

  #rwl62.
    _t62 := n2;

  #rwl63.
    _t63 := i;

  #rwl64.
    _t64 := _t62 + _t63;

  #rwl65.
    _t65 := 2ii;

  #rwl66.
    _t66 := _t64 - _t65;

  #rwl67.
    _t67 := copy_n2;

  #rwl68.
    _t68 := _t60 &&& _t61;

  #rwl69.
    _t69 := _t66 == _t67;

  #l38.
    assert proof__uif__loop_invariant _t68 &&& _t69;

  #l39.
    assert proof__uif__loop_variant { decreases => n2};

  #rwl70.
    _t70 := a2;

  #rwl71.
    _t71 := b2;

  #l40.
    a2 := _t70 + _t71;

  #rwl72.
    _t72 := a2;

  #rwl73.
    _t73 := b2;

  #l41.
    b2 := _t72 - _t73;

  #rwl74.
    _t74 := n2;

  #rwl75.
    _t75 := 1ii;

  #l42.
    n2 := _t74 - _t75;

  #rwl76.
    _t76 := i;

  #rwl77.
    _t77 := 1ii;

  #l43.
    i := _t76 + _t77;

  #l44.
    goto l36;

  #l35.
    // empty loc

  #rwl78.
    _t78 := a1;

  #rwl79.
    _t79 := l1;

  #l47.
    if !(_t78 > _t79) then goto l46;

  #l48.
    l1 := a1;

  #l49.
    goto l45;

  #l46.
    // empty loc

  #l50.
    l1 := 0ii;

  #l45.
    // empty loc

  #rwl80.
    _t80 := a2;

  #rwl81.
    _t81 := l2;

  #l53.
    if !(_t80 > _t81) then goto l52;

  #l54.
    l2 := a2;

  #l55.
    goto l51;

  #l52.
    // empty loc

  #l56.
    l2 := 0ii;

  #l51.
    // empty loc

  #l57.
    return;
}

procedure Natural Factorial (
        Natural n) {
  local
    Natural p;
    Natural i;
    Natural _tcomp2;
    Natural _tcomp3;
    FIXME _t82;
    FIXME _t83;
    FIXME _t84;
    FIXME _t85;
    FIXME _t86;
    FIXME _t87;
    FIXME _t88;
    FIXME _t89;


  #l58.
    p := 1ii;

  #l60.
    _tcomp2 := 2ii;

  #l61.
    _tcomp3 := n;

  #rwl82.
    _t82 := _tcomp2;

  #rwl83.
    _t83 := _tcomp3;

  #l62.
    if _t82 > _t83 then goto l59;

  #l63.
    i := _tcomp2;

  #l64.
    // empty loc

  #rwl84.
    _t84 := i;

  #rwl85.
    _t85 := p;

  #l65.
    p := _t84 * _t85;

  #rwl86.
    _t86 := i;

  #rwl87.
    _t87 := _tcomp3;

  #l66.
    if _t86 == _t87 then goto l59;

  #rwl88.
    _t88 := i;

  #rwl89.
    _t89 := 1ii;

  #l67.
    i := _t88 + _t89;

  #l68.
    goto l64;

  #l59.
    // empty loc

  #l69.
    return p;
}

procedure FactorialSC (
        Natural n1,
        Natural n2,
        Natural p1,
        Natural p2) {
  local
    Natural i;
    Natural _tcomp4;
    Natural _tcomp5;
    Natural i0;
    Natural _tcomp6;
    Natural _tcomp7;
    FIXME _t90;
    FIXME _t91;
    FIXME _t92;
    FIXME _t93;
    FIXME _t94;
    FIXME _t95;
    FIXME _t96;
    FIXME _t97;
    FIXME _t98;
    FIXME _t99;
    FIXME _t100;
    FIXME _t101;
    FIXME _t102;
    FIXME _t103;
    FIXME _t104;
    FIXME _t105;
    FIXME _t106;
    FIXME _t107;
    FIXME _t108;
    FIXME _t109;
    FIXME _t110;
    FIXME _t111;
    FIXME _t112;
    FIXME _t113;


  #l70.
    p1 := 1ii;

  #l72.
    _tcomp4 := 2ii;

  #l73.
    _tcomp5 := n1;

  #rwl90.
    _t90 := _tcomp4;

  #rwl91.
    _t91 := _tcomp5;

  #l74.
    if _t90 > _t91 then goto l71;

  #l75.
    i := _tcomp4;

  #l76.
    // empty loc

  #rwl92.
    _t92 := i;

  #rwl93.
    _t93 := 1ii;

  #rwl94.
    _t94 := p1;

  #rwl95.
    _t95 := Factorial (_t92 - _t93);

  #l77.
    assert proof__uif__loop_invariant _t94 == _t95;

  #rwl96.
    _t96 := i;

  #rwl97.
    _t97 := p1;

  #l78.
    p1 := _t96 * _t97;

  #rwl98.
    _t98 := i;

  #rwl99.
    _t99 := _tcomp5;

  #l79.
    if _t98 == _t99 then goto l71;

  #rwl100.
    _t100 := i;

  #rwl101.
    _t101 := 1ii;

  #l80.
    i := _t100 + _t101;

  #l81.
    goto l76;

  #l71.
    // empty loc

  #l82.
    p2 := 1ii;

  #l84.
    _tcomp6 := 2ii;

  #l85.
    _tcomp7 := n2;

  #rwl102.
    _t102 := _tcomp6;

  #rwl103.
    _t103 := _tcomp7;

  #l86.
    if _t102 > _t103 then goto l83;

  #l87.
    i0 := _tcomp6;

  #l88.
    // empty loc

  #rwl104.
    _t104 := i;

  #rwl105.
    _t105 := 1ii;

  #rwl106.
    _t106 := p2;

  #rwl107.
    _t107 := Factorial (_t104 - _t105);

  #l89.
    assert proof__uif__loop_invariant _t106 == _t107;

  #rwl108.
    _t108 := i;

  #rwl109.
    _t109 := p2;

  #l90.
    p2 := _t108 * _t109;

  #rwl110.
    _t110 := i0;

  #rwl111.
    _t111 := _tcomp7;

  #l91.
    if _t110 == _t111 then goto l83;

  #rwl112.
    _t112 := i0;

  #rwl113.
    _t113 := 1ii;

  #l92.
    i0 := _t112 + _t113;

  #l93.
    goto l88;

  #l83.
    // empty loc

  #l94.
    return;
}

procedure PowerSC (
        Integer a1,
        Integer a2,
        Natural n1,
        Natural n2,
        Integer p1,
        Integer p2) {
  local
    Integer b1;
    Integer b2;
    Natural k1;
    Natural k2;
    FIXME _t114;
    FIXME _t115;
    FIXME _t116;
    FIXME _t117;
    FIXME _t118;
    FIXME _t119;
    FIXME _t120;
    FIXME _t121;
    FIXME _t122;
    FIXME _t123;
    FIXME _t124;
    FIXME _t125;
    FIXME _t126;
    FIXME _t127;
    FIXME _t128;
    FIXME _t129;
    FIXME _t130;
    FIXME _t131;
    FIXME _t132;
    FIXME _t133;
    FIXME _t134;
    FIXME _t135;
    FIXME _t136;
    FIXME _t137;
    FIXME _t138;
    FIXME _t139;
    FIXME _t140;
    FIXME _t141;
    FIXME _t142;
    FIXME _t143;
    FIXME _t144;
    FIXME _t145;
    FIXME _t146;
    FIXME _t147;
    FIXME _t148;
    FIXME _t149;
    FIXME _t150;
    FIXME _t151;
    FIXME _t152;
    FIXME _t153;
    FIXME _t154;
    FIXME _t155;
    FIXME _t156;
    FIXME _t157;
    FIXME _t158;
    FIXME _t159;
    FIXME _t160;
    FIXME _t161;
    FIXME _t162;
    FIXME _t163;
    FIXME _t164;
    FIXME _t165;
    FIXME _t166;
    FIXME _t167;
    FIXME _t168;
    FIXME _t169;
    FIXME _t170;
    FIXME _t171;
    FIXME _t172;
    FIXME _t173;
    FIXME _t174;
    FIXME _t175;
    FIXME _t176;
    FIXME _t177;
    FIXME _t178;
    FIXME _t179;
    FIXME _t180;
    FIXME _t181;
    FIXME _t182;
    FIXME _t183;
    FIXME _t184;
    FIXME _t185;
    FIXME _t186;
    FIXME _t187;
    FIXME _t188;
    FIXME _t189;
    FIXME _t190;
    FIXME _t191;
    FIXME _t192;
    FIXME _t193;
    FIXME _t194;
    FIXME _t195;
    FIXME _t196;
    FIXME _t197;
    FIXME _t198;
    FIXME _t199;
    FIXME _t200;
    FIXME _t201;
    FIXME _t202;
    FIXME _t203;
    FIXME _t204;
    FIXME _t205;
    FIXME _t206;
    FIXME _t207;
    FIXME _t208;
    FIXME _t209;
    FIXME _t210;
    FIXME _t211;
    FIXME _t212;
    FIXME _t213;
    FIXME _t214;
    FIXME _t215;
    FIXME _t216;
    FIXME _t217;
    FIXME _t218;
    FIXME _t219;
    FIXME _t220;
    FIXME _t221;
    FIXME _t222;
    FIXME _t223;
    FIXME _t224;
    FIXME _t225;
    FIXME _t226;
    FIXME _t227;
    FIXME _t228;
    FIXME _t229;


  #l95.
    p1 := 1ii;

  #l96.
    b1 := a1;

  #l97.
    k1 := n1;

  #l99.
    // empty loc

  #rwl114.
    _t114 := k1;

  #rwl115.
    _t115 := 0ii;

  #l100.
    if !(_t114 > _t115) then goto l98;

  #rwl116.
    _t116 := a1;

  #rwl117.
    _t117 := n1;

  #rwl118.
    _t118 := b1;

  #rwl119.
    _t119 := k1;

  #rwl120.
    _t120 := p1;

  #rwl121.
    _t121 := _t118 POWER _t119;

  #rwl122.
    _t122 := _t116 POWER _t117;

  #rwl123.
    _t123 := _t120 * _t121;

  #rwl124.
    _t124 := k1;

  #rwl125.
    _t125 := 0ii;

  #rwl126.
    _t126 := _t122 == _t123;

  #rwl127.
    _t127 := _t124 >= _t125;

  #l101.
    assert proof__uif__loop_invariant _t126 &&& _t127;

  #l102.
    assert proof__uif__loop_variant { decreases => k1};

  #rwl128.
    _t128 := k1;

  #rwl129.
    _t129 := 2ii;

  #rwl130.
    _t130 := _t128 % _t129;

  #rwl131.
    _t131 := 0ii;

  #l105.
    if !(_t130 == _t131) then goto l104;

  #rwl132.
    _t132 := b1;

  #rwl133.
    _t133 := b1;

  #rwl134.
    _t134 := k1;

  #rwl135.
    _t135 := 2ii;

  #rwl136.
    _t136 := _t132 * _t133;

  #rwl137.
    _t137 := _t134 MOD _t135;

  #rwl138.
    _t138 := p1;

  #rwl139.
    _t139 := _t136 POWER _t137;

  #rwl140.
    _t140 := a1;

  #rwl141.
    _t141 := n1;

  #rwl142.
    _t142 := _t138 * _t139;

  #rwl143.
    _t143 := _t140 POWER _t141;

  #l106.
    assert _t142 == _t143;

  #rwl144.
    _t144 := k1;

  #rwl145.
    _t145 := 2ii;

  #l107.
    k1 := _t144 MOD _t145;

  #rwl146.
    _t146 := b1;

  #rwl147.
    _t147 := b1;

  #l108.
    b1 := _t146 * _t147;

  #l109.
    goto l103;

  #l104.
    // empty loc

  #rwl148.
    _t148 := p1;

  #rwl149.
    _t149 := b1;

  #rwl150.
    _t150 := k1;

  #rwl151.
    _t151 := 1ii;

  #rwl152.
    _t152 := b1;

  #rwl153.
    _t153 := _t150 - _t151;

  #rwl154.
    _t154 := _t148 * _t149;

  #rwl155.
    _t155 := _t152 POWER _t153;

  #rwl156.
    _t156 := a1;

  #rwl157.
    _t157 := n1;

  #rwl158.
    _t158 := _t154 * _t155;

  #rwl159.
    _t159 := _t156 POWER _t157;

  #l110.
    assert _t158 == _t159;

  #rwl160.
    _t160 := k1;

  #rwl161.
    _t161 := 1ii;

  #l111.
    k1 := _t160 - _t161;

  #rwl162.
    _t162 := b1;

  #rwl163.
    _t163 := p1;

  #l112.
    p1 := _t162 * _t163;

  #l103.
    // empty loc

  #l113.
    goto l99;

  #l98.
    // empty loc

  #l114.
    p2 := 1ii;

  #l115.
    b2 := a2;

  #l116.
    k2 := n2;

  #l118.
    // empty loc

  #rwl164.
    _t164 := k2;

  #rwl165.
    _t165 := 0ii;

  #l119.
    if !(_t164 > _t165) then goto l117;

  #rwl166.
    _t166 := a2;

  #rwl167.
    _t167 := n2;

  #rwl168.
    _t168 := b2;

  #rwl169.
    _t169 := k2;

  #rwl170.
    _t170 := p2;

  #rwl171.
    _t171 := _t168 POWER _t169;

  #rwl172.
    _t172 := _t166 POWER _t167;

  #rwl173.
    _t173 := _t170 * _t171;

  #rwl174.
    _t174 := k1;

  #rwl175.
    _t175 := 0ii;

  #rwl176.
    _t176 := _t172 == _t173;

  #rwl177.
    _t177 := _t174 >= _t175;

  #rwl178.
    _t178 := a2;

  #rwl179.
    _t179 := n2;

  #rwl180.
    _t180 := p2;

  #rwl181.
    _t181 := _t178 POWER _t179;

  #rwl182.
    _t182 := _t176 &&& _t177;

  #rwl183.
    _t183 := _t180 <= _t181;

  #rwl184.
    _t184 := a2;

  #rwl185.
    _t185 := n2;

  #rwl186.
    _t186 := b2;

  #rwl187.
    _t187 := _t184 POWER _t185;

  #rwl188.
    _t188 := _t182 &&& _t183;

  #rwl189.
    _t189 := _t186 <= _t187;

  #l120.
    assert proof__uif__loop_invariant _t188 &&& _t189;

  #l121.
    assert proof__uif__loop_variant { decreases => k2};

  #rwl190.
    _t190 := k2;

  #rwl191.
    _t191 := 2ii;

  #rwl192.
    _t192 := _t190 % _t191;

  #rwl193.
    _t193 := 0ii;

  #l124.
    if !(_t192 == _t193) then goto l123;

  #rwl194.
    _t194 := b2;

  #rwl195.
    _t195 := b2;

  #rwl196.
    _t196 := k2;

  #rwl197.
    _t197 := 2ii;

  #rwl198.
    _t198 := _t194 * _t195;

  #rwl199.
    _t199 := _t196 MOD _t197;

  #rwl200.
    _t200 := p2;

  #rwl201.
    _t201 := _t198 POWER _t199;

  #rwl202.
    _t202 := a2;

  #rwl203.
    _t203 := n2;

  #rwl204.
    _t204 := _t200 * _t201;

  #rwl205.
    _t205 := _t202 POWER _t203;

  #l125.
    assert _t204 == _t205;

  #rwl206.
    _t206 := k2;

  #rwl207.
    _t207 := 2ii;

  #l126.
    k2 := _t206 MOD _t207;

  #rwl208.
    _t208 := b2;

  #rwl209.
    _t209 := b2;

  #l127.
    b2 := _t208 * _t209;

  #l128.
    goto l122;

  #l123.
    // empty loc

  #rwl210.
    _t210 := p2;

  #rwl211.
    _t211 := b2;

  #rwl212.
    _t212 := k2;

  #rwl213.
    _t213 := 1ii;

  #rwl214.
    _t214 := b2;

  #rwl215.
    _t215 := _t212 - _t213;

  #rwl216.
    _t216 := _t210 * _t211;

  #rwl217.
    _t217 := _t214 POWER _t215;

  #rwl218.
    _t218 := a2;

  #rwl219.
    _t219 := n2;

  #rwl220.
    _t220 := _t216 * _t217;

  #rwl221.
    _t221 := _t218 POWER _t219;

  #rwl222.
    _t222 := k2;

  #rwl223.
    _t223 := 1ii;

  #rwl224.
    _t224 := _t220 == _t221;

  #rwl225.
    _t225 := _t222 >= _t223;

  #l129.
    assert _t224 &&& _t225;

  #rwl226.
    _t226 := k2;

  #rwl227.
    _t227 := 1ii;

  #l130.
    k2 := _t226 - _t227;

  #rwl228.
    _t228 := b2;

  #rwl229.
    _t229 := p2;

  #l131.
    p2 := _t228 * _t229;

  #l122.
    // empty loc

  #l132.
    goto l118;

  #l117.
    // empty loc

  #l133.
    return;
}

procedure ArrayPartitionedTransferSC (
        IntArray A1,
        IntArray A2,
        IntArray B1,
        IntArray B2,
        IntArray C1,
        IntArray C2,
        Natural K1,
        Natural K2) {
  local
    Natural I;
    Natural _tcomp8;
    Natural _tcomp9;
    Natural I0;
    Natural _tcomp10;
    Natural _tcomp11;
    Natural I1;
    Natural _tcomp12;
    Natural _tcomp13;
    Natural I2;
    Natural _tcomp14;
    Natural _tcomp15;
    FIXME _t230;
    FIXME _t231;
    FIXME _t232;
    FIXME _t233;
    FIXME _t234;
    FIXME _t235;
    FIXME _t236;
    FIXME _t237;
    FIXME _t238;
    FIXME _t239;
    FIXME _t240;
    FIXME _t241;
    FIXME _t242;
    FIXME _t243;
    FIXME _t244;
    FIXME _t245;
    FIXME _t246;
    FIXME _t247;
    FIXME _t248;
    FIXME _t249;
    FIXME _t250;
    FIXME _t251;
    FIXME _t252;
    FIXME _t253;
    FIXME _t254;
    FIXME _t255;
    FIXME _t256;
    FIXME _t257;
    FIXME _t258;
    FIXME _t259;
    FIXME _t260;
    FIXME _t261;


  #l135.
    _tcomp8 := attribute__uif__first `A1;

  #l136.
    _tcomp9 := K1;

  #rwl230.
    _t230 := _tcomp8;

  #rwl231.
    _t231 := _tcomp9;

  #l137.
    if _t230 > _t231 then goto l134;

  #l138.
    I := _tcomp8;

  #l139.
    // empty loc

  #l140.
    A1[I] := B1[I];

  #rwl232.
    _t232 := I;

  #rwl233.
    _t233 := _tcomp9;

  #l141.
    if _t232 == _t233 then goto l134;

  #rwl234.
    _t234 := I;

  #rwl235.
    _t235 := 1ii;

  #l142.
    I := _t234 + _t235;

  #l143.
    goto l139;

  #l134.
    // empty loc

  #rwl236.
    _t236 := K1;

  #rwl237.
    _t237 := 1ii;

  #l145.
    _tcomp10 := _t236 + _t237;

  #l146.
    _tcomp11 := attribute__uif__first `A1;

  #rwl238.
    _t238 := _tcomp10;

  #rwl239.
    _t239 := _tcomp11;

  #l147.
    if _t238 > _t239 then goto l144;

  #l148.
    I0 := _tcomp10;

  #l149.
    // empty loc

  #rwl240.
    _t240 := I;

  #rwl241.
    _t241 := K1;

  #l150.
    A1[I] := C1[_t240 - _t241];

  #rwl242.
    _t242 := I0;

  #rwl243.
    _t243 := _tcomp11;

  #l151.
    if _t242 == _t243 then goto l144;

  #rwl244.
    _t244 := I0;

  #rwl245.
    _t245 := 1ii;

  #l152.
    I0 := _t244 + _t245;

  #l153.
    goto l149;

  #l144.
    // empty loc

  #l155.
    _tcomp12 := attribute__uif__first `A2;

  #l156.
    _tcomp13 := K2;

  #rwl246.
    _t246 := _tcomp12;

  #rwl247.
    _t247 := _tcomp13;

  #l157.
    if _t246 > _t247 then goto l154;

  #l158.
    I1 := _tcomp12;

  #l159.
    // empty loc

  #l160.
    A2[I] := B2[I];

  #rwl248.
    _t248 := I1;

  #rwl249.
    _t249 := _tcomp13;

  #l161.
    if _t248 == _t249 then goto l154;

  #rwl250.
    _t250 := I1;

  #rwl251.
    _t251 := 1ii;

  #l162.
    I1 := _t250 + _t251;

  #l163.
    goto l159;

  #l154.
    // empty loc

  #rwl252.
    _t252 := K2;

  #rwl253.
    _t253 := 1ii;

  #l165.
    _tcomp14 := _t252 + _t253;

  #l166.
    _tcomp15 := attribute__uif__last `A2;

  #rwl254.
    _t254 := _tcomp14;

  #rwl255.
    _t255 := _tcomp15;

  #l167.
    if _t254 > _t255 then goto l164;

  #l168.
    I2 := _tcomp14;

  #l169.
    // empty loc

  #rwl256.
    _t256 := I;

  #rwl257.
    _t257 := K2;

  #l170.
    A2[I] := C2[_t256 - _t257];

  #rwl258.
    _t258 := I2;

  #rwl259.
    _t259 := _tcomp15;

  #l171.
    if _t258 == _t259 then goto l164;

  #rwl260.
    _t260 := I2;

  #rwl261.
    _t261 := 1ii;

  #l172.
    I2 := _t260 + _t261;

  #l173.
    goto l169;

  #l164.
    // empty loc

  #l174.
    return;
}

procedure ArrayPartitionedTransferSIFL (
        IntArray A1,
        IntArray A2,
        IntArray B1,
        IntArray B2,
        IntArray C1,
        IntArray C2,
        Natural K) {
  local
    Natural I;
    Natural _tcomp16;
    Natural _tcomp17;
    Natural I0;
    Natural _tcomp18;
    Natural _tcomp19;
    Natural I1;
    Natural _tcomp20;
    Natural _tcomp21;
    Natural I2;
    Natural _tcomp22;
    Natural _tcomp23;
    FIXME _t262;
    FIXME _t263;
    FIXME _t264;
    FIXME _t265;
    FIXME _t266;
    FIXME _t267;
    FIXME _t268;
    FIXME _t269;
    FIXME _t270;
    FIXME _t271;
    FIXME _t272;
    FIXME _t273;
    FIXME _t274;
    FIXME _t275;
    FIXME _t276;
    FIXME _t277;
    FIXME _t278;
    FIXME _t279;
    FIXME _t280;
    FIXME _t281;
    FIXME _t282;
    FIXME _t283;
    FIXME _t284;
    FIXME _t285;
    FIXME _t286;
    FIXME _t287;
    FIXME _t288;
    FIXME _t289;
    FIXME _t290;
    FIXME _t291;
    FIXME _t292;
    FIXME _t293;


  #l176.
    _tcomp16 := attribute__uif__first `A1;

  #l177.
    _tcomp17 := K;

  #rwl262.
    _t262 := _tcomp16;

  #rwl263.
    _t263 := _tcomp17;

  #l178.
    if _t262 > _t263 then goto l175;

  #l179.
    I := _tcomp16;

  #l180.
    // empty loc

  #l181.
    A1[I] := B1[I];

  #rwl264.
    _t264 := I;

  #rwl265.
    _t265 := _tcomp17;

  #l182.
    if _t264 == _t265 then goto l175;

  #rwl266.
    _t266 := I;

  #rwl267.
    _t267 := 1ii;

  #l183.
    I := _t266 + _t267;

  #l184.
    goto l180;

  #l175.
    // empty loc

  #rwl268.
    _t268 := K;

  #rwl269.
    _t269 := 1ii;

  #l186.
    _tcomp18 := _t268 + _t269;

  #l187.
    _tcomp19 := attribute__uif__last `A1;

  #rwl270.
    _t270 := _tcomp18;

  #rwl271.
    _t271 := _tcomp19;

  #l188.
    if _t270 > _t271 then goto l185;

  #l189.
    I0 := _tcomp18;

  #l190.
    // empty loc

  #rwl272.
    _t272 := I;

  #rwl273.
    _t273 := K;

  #l191.
    A1[I] := C1[_t272 - _t273];

  #rwl274.
    _t274 := I0;

  #rwl275.
    _t275 := _tcomp19;

  #l192.
    if _t274 == _t275 then goto l185;

  #rwl276.
    _t276 := I0;

  #rwl277.
    _t277 := 1ii;

  #l193.
    I0 := _t276 + _t277;

  #l194.
    goto l190;

  #l185.
    // empty loc

  #l196.
    _tcomp20 := attribute__uif__first `A2;

  #l197.
    _tcomp21 := K;

  #rwl278.
    _t278 := _tcomp20;

  #rwl279.
    _t279 := _tcomp21;

  #l198.
    if _t278 > _t279 then goto l195;

  #l199.
    I1 := _tcomp20;

  #l200.
    // empty loc

  #l201.
    A2[I] := B2[I];

  #rwl280.
    _t280 := I1;

  #rwl281.
    _t281 := _tcomp21;

  #l202.
    if _t280 == _t281 then goto l195;

  #rwl282.
    _t282 := I1;

  #rwl283.
    _t283 := 1ii;

  #l203.
    I1 := _t282 + _t283;

  #l204.
    goto l200;

  #l195.
    // empty loc

  #rwl284.
    _t284 := K;

  #rwl285.
    _t285 := 1ii;

  #l206.
    _tcomp22 := _t284 + _t285;

  #l207.
    _tcomp23 := attribute__uif__last `A2;

  #rwl286.
    _t286 := _tcomp22;

  #rwl287.
    _t287 := _tcomp23;

  #l208.
    if _t286 > _t287 then goto l205;

  #l209.
    I2 := _tcomp22;

  #l210.
    // empty loc

  #rwl288.
    _t288 := I;

  #rwl289.
    _t289 := K;

  #l211.
    A2[I] := C2[_t288 - _t289];

  #rwl290.
    _t290 := I2;

  #rwl291.
    _t291 := _tcomp23;

  #l212.
    if _t290 == _t291 then goto l205;

  #rwl292.
    _t292 := I2;

  #rwl293.
    _t293 := 1ii;

  #l213.
    I2 := _t292 + _t293;

  #l214.
    goto l210;

  #l205.
    // empty loc

  #l215.
    return;
}package Fib;


typealias Integer anonymousType$0;

typealias _ARRAY_ IntArray;

procedure Natural Fibonacci (
        Natural n) {

}

procedure FibonacciSC (
        Natural n1,
        Natural n2,
        Natural l1,
        Natural l2) {

}

procedure Natural Factorial (
        Natural n) {

}

procedure FactorialSC (
        Natural n1,
        Natural n2,
        Natural p1,
        Natural p2) {

}

procedure PowerSC (
        Integer a1,
        Integer a2,
        Natural n1,
        Natural n2,
        Integer p1,
        Integer p2) {

}

procedure ArrayPartitionedTransferSC (
        IntArray A1,
        IntArray A2,
        IntArray B1,
        IntArray B2,
        IntArray C1,
        IntArray C2,
        Natural K1,
        Natural K2) {

}

procedure ArrayPartitionedTransferSIFL (
        IntArray A1,
        IntArray A2,
        IntArray B1,
        IntArray B2,
        IntArray C1,
        IntArray C2,
        Natural K) {

}package Standard;


typealias Boolean Boolean;

typealias Integer Integer;

typealias Integer Natural;

typealias Integer Positive;

typealias Float Float;

typealias universal_integer universal_integer;

typealias universal_real universal_real;

typealias Character Character;

typealias String String;