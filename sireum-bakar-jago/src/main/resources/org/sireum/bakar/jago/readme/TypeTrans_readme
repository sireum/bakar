/************************************
** Notes about XML To Coq Translation
**           by Zhi Zhang
*************************************/
Look at the following two resources for reference
1. SPARK subset discussed in the email
2. The Coq type should be similar with CompCert Cminor syntax
   at: http://compcert.inria.fr/doc/html/Cminor.html#constant
3. SPARK book "Syntax of core SPARK language"
4. Online syntax:  Collected Syntax of SPARK
   at: http://docs.adacore.com/sparkdocs-docs/SPARK_LRM.htm#_Toc311793240


Notes: 
1. in both stringTemplate for Coq and OCaml, their function name and parameter name are all the same 
   in order to uniform the type translation for either Coq types or OCaml types according to the user 
   selected option: Coq or OCaml
2. In Coq, "option bool" should be written with "bool option" in OCaml
3. In OCaml the type name should not be capital


*************************************
*************************************


SPARK subset syntax from (3)

@@@ 10.1.1
          compilation ::= { compilation_unit }
          compilation_unit ::=
                    context_clause library_item | context_clause subunit
 *       library_item ::= library_unit_declaration | library_unit_body
 *       library_unit_declaration ::=
                    package_declaration | private_package_declaration | main_program
 * 
 *       library_unit_body ::= package_body

7.1
 *       package_declaration ::= [ inherit_clause ] package_specification ;
 +       private_package_declaration ::=
                    [ inherit_clause ] private package_specification ;
 *       package_specification ::=
                      package defining_program_unit_name
                              package_annotation
                      is
                              visible_part
                    [ private
                              private_part ]
                      end [ parent_unit_name . ] identifier
 +       visible_part ::=
                   { renaming_declaration }
                    { package_declarative_item }
 +       package_declarative_item ::=
                     basic_declarative_item    | subprogram_declaration
                                                         | external_subprogram_declaration

7.2
*        package_body ::=
                      package body defining_program_unit_name
                    [ refinement_definition ]
                      is
                              package_implementation
                      end [ parent_unit_name . ] identifier ;
 +       package_implementation ::=
                      declarative_part
                    [ begin
                              package_initialization ]
 
 

@@@ 6.1
 *       subprogram_declaration ::= 
                    procedure_specification ; procedure_annotation
             |      function_specification ; function_annotation
             
@@@ 6.3
 *       subprogram_body ::= 
                      procedure_specification
                    [ procedure_annotation ]
                      is
                      subprogram_implementation
             |        function_specification
                    [ function_annotation ]
                      is
                      subprogram_implementation

///////////////////////////////////////////////////////////////////////////////////////////

 +       subprogram_implementation ::=
                              declarative_part
                      begin
                              sequence_of_statements
                      end designator ;
             |        begin
                              code_insertion
                      end designator ;
+        code_insertion ::= code_statement { code_statement }

 *        sequence_of_statements ::= statement { statement }
          statement ::= 
                    { label } simple_statement  |  { label } compound_statement
 *       simple_statement ::= null_statement
             |      assignment_statement               |  procedure_call_statement
             |      exit_statement                          |  return_statement
             |    entry_call_statement                   |  delay_statement
 *       compound_statement ::= 
                    if_statement                              |  case_statement 
             |      loop_statement

 *     declarative_part ::=
            { renaming_declaration }
            { declarative_item           |  ... }
       declarative_item ::= basic_declarative_item  |  ...
 *     basic_declarative_item ::=
            basic_declaration  |  representation_clause

 *     basic_declaration ::=
                 type_declaration   
            |    object_declaration                     | ...
            
 *       object_declaration ::=
                   defining_identifier_list : [ constant ] subtype_mark [ := expression ] ;
          defining_identifier_list ::= defining_identifier { , defining_identifier }

///////////////////////////////////////////////////////////////////////////////////////////

 *       procedure_specification ::=
                    procedure defining_identifier parameter_profile
          function_specification ::=
                    function defining_designator parameter_and_result_profile
 *       designator ::= identifier
 *       defining_designator ::= defining_identifier
          defining_program_unit_name ::= [ parent_unit_name . ] defining_identifier
          operator_symbol ::= string_literal
          defining_operator_symbol ::= operator_symbol
          parameter_profile ::= [ formal_part ]
 *       parameter_and_result_profile::= [ formal_part ] return subtype_mark
          formal_part ::=
                    ( parameter_specification { ; parameter_specification } )   
 *       parameter_specification ::=
                    defining_identifier_list : mode subtype_mark
          mode ::= [ in ] | in out | out
          
6.1.1
 +       procedure_annotation ::=
                    [ global_definition ]
                    [ dependency_relation ]
                    [ declare_annotation ]
 +       function_annotation ::=
                    [ global_definition ]
   
6.1.2
 +       global_definition ::=
                   --# global global_mode global_variable_list ; { global_mode global_variable_list ; }
 +       global_mode ::= in | in out | out
 +       global_variable_list ::= global_variable { , global_variable }
 +       global_variable ::= entire_variable
 +       entire_variable ::= [ package_name . ]  direct_name
 +       dependency_relation ::=
            --# derives [dependency_clause { & dependency_clause } [& null_dependency_clause]] ;
          |  --# derives null_dependency_clause ;
 +       dependency_clause ::= 
                    exported_variable_list from [ imported_variable_list ]
 +       exported_variable_list ::= exported_variable { , exported_variable }
 +       exported_variable ::= entire_variable
 +       imported_variable_list ::= *  |  [ * , ] imported_variable { , imported_variable }
 +       imported_variable ::= entire_variable
 +       null_dependency_clause ::= null from imported_variable { , imported_variable }
 
 
 
 
 
 
 
 
 
 
 
 
 