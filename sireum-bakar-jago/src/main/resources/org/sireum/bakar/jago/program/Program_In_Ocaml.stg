// group SPARKTRANS_OCaml_MODEL;

optionVal(value) ::= <<
$if(value)$Some($value$)$else$None$endif$ 
>>

binaryExpr(astnum, op, loperand, roperand) ::= <<
E_Binary_Operation ($astnum$, $op$, $loperand$, $roperand$)
>>

unaryExpr(astnum, op, operand) ::= <<
E_Unary_Operation ($astnum$, $op$, $operand$)
>>

// identifier is either (1) Bid nat; or (2) Aid nat 
varId(theType, id, annotation) ::= <<
$theType$ $if(annotation)$(*$annotation$*)$endif$ $id$
>>

identifierExpr(astnum, id) ::= <<
E_Identifier ($astnum$, $id$)
>>

// Inductive literal: Type := 
//     | Integer_Literal: nat -> constant
// the type is "Integer_Literal", the value is of type nat
// $if(theType)$$theType$ $endif$$constVal$
literal(theType, theLiteral) ::= <<
$theType$ $theLiteral$
>>

literalExpr(astnum, litval) ::= <<
E_Literal ($astnum$, $litval$)
>>

// procedureCall(procName, args) ::= <<
// $procName$($args; separator=", "$)
// >>

seqStmt(astnum, stmt1, stmt2) ::= <<
S_Sequence ($astnum$,
  $stmt1$,
  $stmt2$ )
>>

assertStmt(astnum, assertExp) ::= <<
S_Assert ($astnum$, $assertExp$)
>>	

loopInvariantStmt(astnum, invariantExp) ::= <<
S_Loop_Invariant ($astnum$, $invariantExp$)
>>

whileStmt(astnum, cond, loopBody) ::= <<
S_While_Loop ($astnum$, $cond$,
  $loopBody$
)
>>

ifStmt(astnum, cond, ifBody) ::= <<
S_If ($astnum$, $cond$,
  $ifBody$
)
>>

assignStmt(astnum, lhs, rhs) ::= <<
S_Assignment ($astnum$, $lhs$, $rhs$)
>>

returnStmt(astnum, returnExp) ::= <<
S_Return ($astnum$, $if(returnExp)$(Some ($returnExp$))$else$None$endif$)
>>

//paramSpecification(astnum, ids, theType, mode, initExp) ::= <<
//{ parameter_astnum = $astnum$; parameter_names = [$ids; separator="; "$]; parameter_subtype_mark = $theType$; parameter_mode = $mode$; parameter_default_expression = $if(initExp)$(Some ($initExp$))$else$None$endif$ }
//>>
paramSpecification(astnum, id, theType, mode, initExp) ::= <<
{ parameter_astnum = $astnum$; parameter_name = $id$; parameter_subtype_mark = $theType$; parameter_mode = $mode$; parameter_default_expression = $if(initExp)$(Some ($initExp$))$else$None$endif$ }
>>

aspectSpecification(astnum, aspectMark, aspectDef) ::= <<
{ 
  aspect_astnum = 
    $astnum$;
  aspect_mark = 
    $aspectMark$; 
  aspect_definition = 
    $aspectDef$
}
>>

// +++++++++
//objectDeclaration(astnum, ids, theType, init) ::= <<
//{ declaration_astnum = $astnum$; object_names = [$ids; separator="; "$]; object_nominal_subtype = $theType$; initialization_expression = $if(init)$(Some ($init$))$else$None$endif$ }
//>>
objectDeclaration(astnum, id, theType, init) ::= <<
{ declaration_astnum = $astnum$; object_name = $id$; object_nominal_subtype = $theType$; initialization_expression = $if(init)$(Some ($init$))$else$None$endif$ }
>>

// ++++++
procedureBody(astnum, procName, aspectSpecs, params, identDecls, procBody) ::= <<
{ 
  procedure_astnum = 
    (* Procedure Body - AST Number *)
    $astnum$;
  procedure_name = 
    (* Procedure Body - Name *)
    $procName$;
  procedure_contracts =
    (* Procedure Body - Specification *)
    [$if(aspectSpecs)$
    $aspectSpecs; separator="; \n"$$endif$];
  procedure_parameter_profile = 
    (* Procedure Body - Parameters *)
    [$if(params)$
    $params; separator="; \n"$$endif$];
  procedure_declarative_part = 
    (* Procedure Body - Variable Declarations *)
    [$if(identDecls)$
    $identDecls; separator="; \n"$$endif$];
  procedure_statements =
    (* Procedure Body - Statements *)
    $procBody$
}
>>

// ++++
functionBody(astnum, funcName, aspectSpecs, returnT, params, identDecls, funcBody) ::= <<
{
  function_astnum =   
    (* Function Body - AST Number *)
    $astnum$; 
  function_name =
    (* Function Body - Name *)
    $funcName$;
  function_result_subtype = 
    (* Function Body - Return Type *)
    $returnT$;
  function_contracts = 
    (* Function Body - Specification *)
    [$if(aspectSpecs)$
    $aspectSpecs; separator="; \n"$$endif$];
  function_parameter_profile = 
    (* Function Body - Parameters *)
    [$if(params)$
    $params; separator="; \n"$$endif$];
  function_declarative_part = 
    (* Function Body - Locally Defined Variables *)
    [$if(identDecls)$
    $identDecls; separator="; \n"$$endif$];
  function_statements = 
    (* Function Body - Statements *)
    $funcBody$
}
>>

// <Procedure procedure_body> or <Function function_body>
subProgram(astnum, kind, prog, annotation) ::= <<
(* $annotation$ Body Declaration *)
$kind$( $astnum$,
  $prog$
)
>>

// ++++++
packageBody(astnum, pkgBodyName, pkgBodyAspectSpecs, pkgBodyDeclItems) ::= <<
(* Package Body Declaration *)
PackageBody ( $astnum$,
  (* Package Body - Name *)
  $pkgBodyName$,
  (* Package Body - Specification *)
  $if(pkgBodyAspectSpecs)$
  $pkgBodyAspectSpecs; separator="; \n"$$else$
  None$endif$, 
  (* Package Body - Declared Items *)
  [
    $pkgBodyDeclItems; separator="; \n"$
  ]
)
>>

unitDeclaration(astnum, kind, packageUnit) ::= <<
$kind$( $astnum$,
  $packageUnit$
)
>>

compilationUnit(astnum, unitDecl, unitExpTypeTable, unitTypeNameTable) ::= <<
(* Compilation Unit *)
Library_Unit ( $astnum$,
  (* Compilation Unit - Unit Declaration *)
  $unitDecl$,  
  (* Compilation Unit - Type Table *)
  {
    tt_exptype_table = 
      (* Expression AstNum --> TypeNum *) 
      [
        $unitExpTypeTable; separator=" ;\n"$
      ];
    tt_typename_table = 
      (* TypeNum --> (Type URI * (Type Declaration AST Num) Option) *) 
      [
        $unitTypeNameTable; separator=" ;\n"$
      ]
  }
)
>>

stringFormat(value) ::= <<
"$value$"
>>

mappingPair(key, value) ::= <<
($key$, $value$)
>>



