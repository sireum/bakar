// group SPARKTRANS_Coq_MODEL;

optionVal(value) ::= <<
$if(value)$Some($value$)$else$None$endif$ 
>>

list(elements) ::= <<
($if(elements)$$elements; separator=" :: "$ :: $endif$nil)
>>

literal(theType, theLiteral) ::= <<
($theType$ $theLiteral$)
>>

literalExpr(astnum, litval, checks) ::= <<
(E_Literal_XX $astnum$ $litval$ (*$checks$*))
>>

binaryExpr(astnum, op, loperand, roperand, checks) ::= <<
(E_Binary_Operation_XX $astnum$ $op$ $loperand$ $roperand$ (*checks*))
>>

unaryExpr(astnum, op, operand, checks) ::= <<
(E_Unary_Operation_XX $astnum$ $op$ $operand$ (*checks*))
>>

nameExpr(astnum, x, checks) ::= <<
(E_Name_XX $astnum$ $x$ (*checks*))
>>

varId(id, annotation) ::= <<
($if(annotation)$(*$annotation$*) $endif$$id$)
>>

identifierExpr(astnum, id, checks) ::= <<
(E_Identifier_XX $astnum$ $id$ (*checks*))
>>

// x[e]
indexedComponent(astnum, x_astnum, x, e, checks) ::= <<
(E_Indexed_Component_XX $astnum$ $x_astnum$ $x$ $e$ (*checks*))
>>

// x.f
selectedComponent(astnum, x_astnum, x, f, checks) ::= <<
(E_Selected_Component_XX $astnum$ $x_astnum$ $x$ $f$ (*checks*))
>>

nullStmt() ::= <<
S_Null_XX
>>

assignStmt(astnum, lhs, rhs) ::= <<
(S_Assignment_XX $astnum$ $lhs$ $rhs$)
>>

ifStmt(astnum, cond, trueBranch, falseBranch) ::= <<
(S_If_XX $astnum$ $cond$
  $trueBranch$
  $if(falseBranch)$$falseBranch$$else$$nullStmt()$$endif$
)
>>

whileStmt(astnum, cond, loopBody) ::= <<
(S_While_Loop_XX $astnum$ $cond$
  $loopBody$
)
>>

procedureCall(astnum, p_astnum, p, args) ::= <<
(S_Procedure_Call_XX $astnum$ $p_astnum$ $p$ 
  $args$
)
>>

seqStmt(astnum, stmt1, stmt2) ::= <<
(S_Sequence_XX $astnum$
  $stmt1$ 
  $stmt2$
)
>>

returnStmt(astnum, returnExp) ::= <<
(S_Return_XX $astnum$ $if(returnExp)$(Some ($returnExp$))$else$None$endif$)
>>

assertStmt(astnum, assertExp) ::= <<
(S_Assert_XX $astnum$ $assertExp$)
>>	

loopInvariantStmt(astnum, invariantExp) ::= <<
(S_Loop_Invariant_XX $astnum$ $invariantExp$)
>>

fieldDeclaration(fieldName, fieldType) ::= <<
($fieldName$, $fieldType$)
>>

arrayTypeDecl(astnum, tid, theType, low, upper) ::= <<
(Array_Type_Declaration_XX $astnum$ $tid$ $theType$ $low$ $upper$)
>>

recordTypeDecl(astnum, tid, fields) ::= <<
(Record_Type_Declaration_XX $astnum$ $tid$ $fields$)
>>

objectDeclaration(astnum, id, theType, init) ::= <<
(mkobject_declaration_xx $astnum$ $id$ $theType$ $if(init)$(Some ($init$))$else$None$endif$)
>>

paramSpecification(astnum, id, theType, mode) ::= <<
(mkparameter_specification_xx $astnum$ $id$ ($theType$) $if(mode)$$mode$$else$In$endif$)
>>

aspectSpecification(astnum, aspectMark, aspectDef) ::= <<
(mkaspect_specification_xx $astnum$
  (* Aspect Mark *)
  $aspectMark$
  (* Aspect Definition *)
  $aspectDef$
)
>>

procedureBodyDeclaration(astnum, procName, aspectSpecs, params, identDecls, procBody) ::= <<
(mkprocedure_declaration_xx $astnum$
  (* Procedure Body - Name *)
  $procName$
  (* Procedure Body - Specification *)
  ($if(aspectSpecs)$
  $aspectSpecs; separator=" :: \n"$ :: $endif$nil)
  (* Procedure Body - Parameters *)
  ($if(params)$
  $params; separator=" :: \n"$ :: $endif$nil) 
  (* Procedure Body - Variable Declarations *)
  ($if(identDecls)$
  $identDecls; separator=" :: \n"$ :: $endif$nil)
  (* Procedure Body - Statements *) (
    $procBody$
  )
)
>>

functionBodyDeclaration(astnum, funcName, aspectSpecs, returnT, params, identDecls, funcBody) ::= <<
(mkfunction_declaration_xx $astnum$
  (* Function Body - Name *)
  $funcName$
  (* Function Body - Return Type *) 
  $returnT$ 
  (* Function Body - Specification *)
  ($if(aspectSpecs)$
  $aspectSpecs; separator=" :: \n"$ :: $endif$nil)
  (* Function Body - Parameters *)
  ($if(params)$
  $params; separator=" :: \n"$ :: $endif$nil)
  (* Function Body - Local Defined Variables *)
  ($if(identDecls)$
  $identDecls; separator=" :: \n"$ :: $endif$nil)
  (* Function Body - Statements *) (
    $funcBody$
  )
)
>>

// <Procedure procedure_body> or <Function function_body>
// <annotation> can be either "Procedure" or "Function"
subProgram(astnum, kind, prog, annotation) ::= <<
(* $annotation$ Body Declaration *)
($kind$ $astnum$ (
  $prog$
  )
)
>>

packageBody(astnum, pkgBodyName, pkgBodyAspectSpecs, pkgBodyDeclItems) ::= <<
(* Package Body Declaration *)
(PackageBody $astnum$
  (* Package Body - Name *)
  $pkgBodyName$
  (* Package Body - Specification *)
  ($if(pkgBodyAspectSpecs)$
  $pkgBodyAspectSpecs; separator = " ::\n"$ :: nil$else$None$endif$)    
  (* Package Body - Declared Items *) (
    $pkgBodyDeclItems; separator=" ::\n\n"$ :: nil
  )
)
>>

unitDeclaration(astnum, kind, packageUnit) ::= <<
$kind$ $astnum$ (
  $packageUnit$
)
>>

compilationUnit(astnum, unitDecl, unitExpTypeTable, unitTypeNameTable) ::= <<
(* Compilation Unit *)
Library_Unit_XX $astnum$
  (* Compilation Unit - Unit Declaration *) (
    $unitDecl$
  )
  (* Compilation Unit - Type Table *) (
    mktype_table (
      (* Expression Type Table: Expression AstNum --> TypeNum *)
      $unitExpTypeTable; separator=" ::\n"$ :: nil
    ) (
      (* Type Name Table: TypeNum --> (Type URI * Option(Type Declaration AST Num)) *)
      $unitTypeNameTable; separator=" ::\n"$ :: nil
    )
  )
>>

// in Coq, it is something like "hello"%string
stringFormat(value) ::= <<
"$value$"%string
>>

mappingPair(key, value) ::= <<
($key$, $value$)
>>

