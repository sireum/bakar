// group SPARKTRANS_Coq_MODEL;

optionVal(value) ::= <<
$if(value)$Some($value$)$else$None$endif$ 
>>

binaryExpr(astnum, op, loperand, roperand) ::= <<
Ebinop $astnum$ $op$ ($loperand$) ($roperand$)
>>

unaryExpr(astnum, op, operand) ::= <<
Eunop $astnum$ $op$ ($operand$)
>>

varId(id, annotation) ::= <<
$if(annotation)$(*$annotation$*) $endif$$id$
>>

identifierExpr(astnum, id) ::= <<
Evar $astnum$ $id$
>>

// Inductive constant: Type := 
//     | Ointconst: nat -> constant
// the type is "Ointconst", the value is of type nat
constant(theType, constVal) ::= <<
$theType$ $constVal$
>>

constantExpr(astnum, constVal) ::= <<
Econst $astnum$ ($constVal$)
>>

procedureCall(procName, args) ::= <<
$procName$($args; separator=", "$)
>>

seqStmt(astnum, stmt1, stmt2) ::= <<
Sseq $astnum$ (
  $stmt1$ ) ( 
  $stmt2$ )
>>

whileStmt(astnum, cond, loopInv, loopBody) ::= <<
Swhile $astnum$ ($cond$) ($if(loopInv)$
    $loopInv$$else$
    None$endif$ ) (
    $loopBody$
  )
>>

ifStmt(astnum, cond, ifBody) ::= <<
Sifthen $astnum$ ($cond$) (
    $ifBody$
  )
>>

assignStmt(astnum, lhs, rhs) ::= <<
Sassign $astnum$ ($lhs$) ($rhs$)
>>

param(astnum, id, mode, initExp) ::= <<
mkparam $astnum$ ($id$) $if(mode)$($mode$)$else$In$endif$ $if(initExp)$($initExp$)$else$None$endif$
>>

subprogAspectSpecs(astnum, pre, post) ::= <<
mksubprog_aspect_specs $astnum$
  (* Precondition *)
  ($if(pre)$
  $pre$$else$None$endif$) 
  (* Postcondition *)
  ($if(post)$
  $post$$else$None$endif$)
>>

identiferDecl(astnum, ids, init) ::= <<
mklocal_ident $astnum$ ($ids; separator=" :: "$ :: nil) $if(init)$$init$$else$None$endif$
>>

procedureBody(astnum, procName, aspectSpecs, params, identDecls, procBody) ::= <<
mkprocedure_body $astnum$
  (* Procedure Body - Name *)
  $procName$
  (* Procedure Body - Specification *)
  ($if(aspectSpecs)$
  $aspectSpecs$$else$None$endif$)
  (* Procedure Body - Parameters *)
  ($if(params)$Some(
    $params; separator=" :: \n"$ ::
    nil
  )$else$None$endif$) 
  (* Procedure Body - Locally Defined Variables *)
  ($if(identDecls)$Some(
    $identDecls; separator=" :: \n"$ ::
    nil
  )$else$None$endif$)
  (* Procedure Body - Body *) (
    $procBody$
  )
>>

functionBody(astnum, funcName, aspectSpecs, returnT, params, identDecls, funcBody) ::= <<
mkfunction_body $astnum$
  (* Function Body - Name *)
  $funcName$
  (* Function Body - Specification *)
  ($if(aspectSpecs)$
  $aspectSpecs$$else$None$endif$)
  (* Function Body - Return Type *) 
  ($returnT$) 
  (* Function Body - Parameters *)
  ($if(params)$Some(
    $params; separator=" :: \n"$ ::
    nil
  )$else$None$endif$)
  (* Function Body - Locally Defined Variables *)
  ($if(identDecls)$Some(
    $identDecls; separator=" :: \n"$ ::
    nil
  )$else$None$endif$)
  (* Function Body - Body *) (
    $funcBody$
  )
>>

// <Sproc procedure_body> or <Sfunc function_body>
// <annotation> can be either "Procedure" or "Function"
subProgram(astnum, kind, prog, annotation) ::= <<
(* $annotation$ Body Declaration *)
$kind$ $astnum$
  ($prog$)
>>

packageBody(astnum, pkgBodyName, pkgBodyAspectSpecs, pkgBodyDeclItems) ::= <<
(* Package Body Declaration *)
Packagebody $astnum$
  (* Package Body - Name *)
  ($pkgBodyName$)
  (* Package Body - Specification *)
  ($if(pkgBodyAspectSpecs)$
  $pkgBodyAspectSpecs$$else$None$endif$)    
  (* Package Body - Declared Items *) (
    $pkgBodyDeclItems; separator=" ::\n\n"$ ::
    nil
  )
>>

compilationUnit(astnum, unitName, unitDecl,
  unitExpTypeTable, unitTypeNameTable, unitTypeDeclAst) ::= <<
(* Compilation Unit Declaration *)
PkgBodyDecl $astnum$
  (* Compilation Unit - Name *)
  ($unitName$)
  (* Compilation Unit - Unit Declaration *) (
    $unitDecl$
  )
  (* Compilation Unit - Type Table *) (
    mktype_table (
      (* Expression Type Table: Expression AstNum --> TypeNum *)
      $unitExpTypeTable; separator=" ::\n"$ ::
      nil
    ) (
      (* Type Name Table: TypeNum --> Type Name * Type Declaration AST Num *)
      $unitTypeNameTable; separator=" ::\n"$ ::
      nil
    )
  )
>>

// for example: "hello"%string
context(value, ctxt) ::= <<
$value$%$ctxt$
>>

mappingPair(key, value) ::= <<
($key$, $value$)
>>

location(line, col, endline, endcol) ::= <<
Loc ($line$, $col$) ($endline$, $endcol$)
>>

