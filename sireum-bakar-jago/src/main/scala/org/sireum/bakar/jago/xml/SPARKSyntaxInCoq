Require Export ZArith. 
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Strings.String.

(* Module SPARK_Syntax. *)
Inductive mode: Type := 
    | In: mode
    | Out: mode.

Inductive typ: Type := 
    | Tint: typ
    | Tbool: typ.

Definition idnum := nat.

Definition astnum := nat.

Definition procnum := nat.

Definition typenum := nat.

Definition typeuri := string.

Record type_table: Type := mktype_table{
    tt_ast_table: list (nat * nat);
    tt_typeuri_table: list (nat * (string * option nat))
}.

Inductive location := 
    | Loc: nat * nat -> nat * nat -> location.

Inductive value: Type := 
    | Aval: nat -> value
    | Bval: bool -> value.

Inductive constant: Type := 
	| Ointconst: nat -> constant.

Inductive unary_operation: Type := 
	| Onegint: unary_operation
	| Oposint: unary_operation.

Inductive binary_operation: Type := 
	| Ceq: binary_operation
	| Cge: binary_operation
	| Cgt: binary_operation
	| Cle: binary_operation
	| Clt: binary_operation
	| Cne: binary_operation
	| Oadd: binary_operation
	| Oand: binary_operation
	| Odiv: binary_operation
	| Omul: binary_operation
	| Oor: binary_operation
	| Osub: binary_operation
	| Oxor: binary_operation.

Inductive expr: Type := 
	| Econst: astnum -> constant -> expr
	| Evar: astnum -> idnum -> expr
	| Ebinop: astnum -> binary_operation -> expr -> expr -> expr
	| Eunop: astnum -> unary_operation -> expr -> expr.

Definition predicate := expr.

Definition loopInvariant := option (predicate).

Inductive stmt: Type := 
	| Sassign: astnum -> idnum -> expr -> stmt
	| Sifthen: astnum -> expr -> stmt -> stmt
	| Swhile: astnum -> expr -> loopInvariant -> stmt -> stmt
	| Sseq: astnum -> stmt -> stmt -> stmt.

Record param: Type := mkparam{
	param_astnum: astnum;
	param_ident: idnum;
	param_mode: mode;
	param_init: option (expr)
}.

Record subprog_aspect_specs: Type := mksubprog_aspect_specs{
	specs_astnum: astnum;
	pre: option (predicate);
	post: option (predicate)
}.

(* Local variables declarations used in the procedure/function body *)
Record local_ident: Type := mklocal_ident{
	local_astnum: astnum;
	local_idents: list idnum;
	local_init: option (value)
}.

Record procedure_body: Type := mkprocedure_body{
	proc_astnum: astnum;
	proc_name: procnum;
	proc_specs: option (subprog_aspect_specs);
	proc_params: option (list param);
	proc_loc_idents: option (list local_ident);
	proc_body: stmt
}.

Record function_body: Type := mkfunction_body{
	fn_astnum: astnum;
	fn_name: procnum;
	fn_specs: option (subprog_aspect_specs);
	fn_ret_type: typ;
	fn_params: option (list param);
	fn_loc_idents: option (list local_ident);
	fn_body: stmt
}.

Inductive subprogram: Type := 
	| Sproc: astnum -> procedure_body -> subprogram
	| Sfunc: astnum -> function_body -> subprogram.

Definition pkgbody_aspect_specs := subprog_aspect_specs.

Inductive package_body: Type := 
	| Packagebody: astnum -> procnum -> option (pkgbody_aspect_specs) -> list subprogram -> package_body.

(* compilation unit can be either package_declaration or package_body_declaration *)
Inductive compilation_unit: Type := 
	| PkgBodyDecl: astnum -> procnum -> package_body -> type_table -> compilation_unit.

(* End SPARK_Syntax. *)
(* Extraction SPARK_Syntax. *)
(* Recursive Extraction program. *)