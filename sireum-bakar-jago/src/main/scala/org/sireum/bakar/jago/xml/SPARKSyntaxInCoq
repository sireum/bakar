Require Export ZArith. 
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.

(* Module SPARK_Syntax. *)
Inductive mode: Type := 
    | In: mode
    | Out: mode.

Inductive typ: Type := 
    | Tint: typ
    | Tbool: typ.

Definition ident := nat.

Definition uri := nat.

Inductive location := 
    | Loc: nat * nat -> nat * nat -> location.

Inductive value: Type := 
    | Aval: nat -> value
    | Bval: bool -> value.

Inductive constant: Type := 
	| Ointconst: nat -> constant.

Inductive unary_operation: Type := 
	| Onegint: unary_operation
	| Oposint: unary_operation.

Inductive binary_operation: Type := 
	| Ceq: binary_operation
	| Cge: binary_operation
	| Cgt: binary_operation
	| Cle: binary_operation
	| Clt: binary_operation
	| Cne: binary_operation
	| Oadd: binary_operation
	| Oand: binary_operation
	| Odiv: binary_operation
	| Omul: binary_operation
	| Oor: binary_operation
	| Osub: binary_operation
	| Oxor: binary_operation.

Inductive expr: Type := 
	| Econst: uri -> constant -> expr
	| Evar: uri -> ident -> expr
	| Ebinop: uri -> binary_operation -> expr -> expr -> expr
	| Eunop: uri -> unary_operation -> expr -> expr.

Definition predicate := expr.

Definition loopInvariant := option (predicate).

Inductive stmt: Type := 
	| Sassign: uri -> ident -> expr -> stmt
	| Sifthen: uri -> expr -> stmt -> stmt
	| Swhile: uri -> expr -> loopInvariant -> stmt -> stmt
	| Sseq: uri -> stmt -> stmt -> stmt.

Record param: Type := mkparam{
	param_uri: uri;
	param_ident: ident;
	param_mode: mode;
	param_init: option (expr)
}.

Record subprog_aspect_specs: Type := mksubprog_aspect_specs{
	specs_uri: uri;
	pre: option (predicate);
	post: option (predicate)
}.

(* Local variables declarations used in the procedure/function body *)
Record defining_ident: Type := mkdefining_ident{
	local_uri: uri;
	local_idents: list ident;
	local_init: option (value)
}.

Record procedure_body: Type := mkprocedure_body{
	proc_uri: uri;
	proc_name: ident;
	proc_specs: option (subprog_aspect_specs);
	proc_params: option (list param);
	proc_loc_idents: option (list defining_ident);
	proc_body: stmt
}.

Record function_body: Type := mkfunction_body{
	fn_uri: uri;
	fn_name: ident;
	fn_specs: option (subprog_aspect_specs);
	fn_ret_type: typ;
	fn_params: option (list param);
	fn_loc_idents: option (list defining_ident);
	fn_body: stmt
}.

Inductive subprogram: Type := 
	| Sproc: uri -> procedure_body -> subprogram
	| Sfunc: uri -> function_body -> subprogram.

Definition pkgbody_aspect_specs := subprog_aspect_specs.

Inductive package_body: Type := 
	| Packagebody: uri -> ident -> option (pkgbody_aspect_specs) -> list subprogram -> package_body.

(* compilation unit can be either package_declaration or package_body_declaration *)
Inductive compilation_unit: Type := 
	| PkgBodyDecl: uri -> ident -> location -> package_body -> compilation_unit.

(* End SPARK_Syntax. *)
(* Extraction SPARK_Syntax. *)
(* Recursive Extraction program. *)