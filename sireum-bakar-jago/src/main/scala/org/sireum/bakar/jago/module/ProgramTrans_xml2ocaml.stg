// group SPARKTRANS_OCaml_MODEL;

optionVal(value) ::= <<
$if(value)$Some($value$)$else$None$endif$ 
>>

binaryExpr(uri, op, loperand, roperand) ::= <<
Ebinop ($op$, $loperand$, $roperand$, $uri$)
>>

unaryExpr(uri, op, operand) ::= <<
Eunop ($op$, $operand$, $uri$)
>>

// identifier is either (1) Bid nat; or (2) Aid nat 
varId(theType, id, annotation) ::= <<
$theType$ $if(annotation)$(*$annotation$*)$endif$ $id$
>>

identifierExpr(uri, id) ::= <<
Evar ($id$, $uri$)
>>

// Inductive constant: Type := 
//     | Ointconst: nat -> constant
// the type is "Ointconst", the value is of type nat
// $if(theType)$$theType$ $endif$$constVal$
constant(theType, constVal) ::= <<
$constVal$
>>

constantExpr(uri, constVal) ::= <<
Econst ($constVal$, $uri$)
>>

// procedureCall(procName, args) ::= <<
// $procName$($args; separator=", "$)
// >>

seqStmt(uri, stmt1, stmt2) ::= <<
Sseq (
  $stmt1$,
  $stmt2$,
  $uri$ )
>>

whileStmt(uri, cond, loopInv, loopBody) ::= <<
Swhile ($cond$, 
  $if(loopInv)$
  $loopInv$$else$
  None$endif$,
  $loopBody$,
  $uri$
)
>>

ifStmt(uri, cond, ifBody) ::= <<
Sifthen ($cond$,
  $ifBody$,
  $uri$
)
>>

assignStmt(uri, lhs, rhs) ::= <<
Sassign ($lhs$, $rhs$, $uri$)
>>

param(uri, id, mode, initExp) ::= <<
{ param_ident = $id$; param_mode = $mode$; param_init = $if(initExp)$$initExp$$else$None$endif$; param_uri = $uri$ }
>>

subprogAspectSpecs(uri, pre, post) ::= <<
{ pre = 
    (* Precondition *)
    $if(pre)$
    $pre$$else$None$endif$; 
  post = 
    (* Postcondition *)
    $if(post)$
    $post$$else$None$endif$;
  specs_uri = 
    (* URI *)
    $uri$ 
}
>>

// +++++++++
identiferDecl(uri, ids, init) ::= <<
{ local_idents = [$ids; separator="; "$]; local_init = $if(init)$$init$$else$None$endif$; local_uri = $uri$ }
>>

// ++++++
procedureBody(uri, procName, aspectSpecs, params, identDecls, procBody) ::= <<
{ 
  proc_name = 
    (* Procedure Body - Name *)
    $procName$;
  proc_specs =
    (* Procedure Body - Specification *)
    $if(aspectSpecs)$
    $aspectSpecs$$else$
    None$endif$;
  proc_params = 
    (* Procedure Body - Parameters *)
    $if(params)$Some([
      $params; separator="; \n"$
    ])$else$
    None$endif$;
  proc_defidents = 
    (* Procedure Body - Locally Defined Variables *)
    $if(identDecls)$Some([
      $identDecls; separator="; \n"$
    ])$else$
    None$endif$;
  proc_body =
    (* Procedure Body - Body *)
    $procBody$;
  proc_uri = 
    (* Procedure Body - URI *)
    $uri$;
}
>>

// ++++
functionBody(uri, funcName, aspectSpecs, returnT, params, identDecls, funcBody) ::= <<
{ 
  fn_name =
    (* Function Body - Name *)
    $funcName$;
  fn_specs = 
    (* Function Body - Specification *)
    $if(aspectSpecs)$
    $aspectSpecs$$else$
    None$endif$;
  fn_retT = 
    (* Function Body - Return Type *)
    $returnT$;
  fn_params = 
    (* Function Body - Parameters *)
    $if(params)$Some([
      $params; separator="; \n"$
    ])$else$
    None$endif$;
  fn_defidents = 
    (* Function Body - Locally Defined Variables *)
    $if(identDecls)$Some([
      $identDecls; separator="; \n"$
    ])$else$
    None$endif$;
  fn_body = 
    (* Function Body - Body *)
    $funcBody$;
  fn_uri =   
    (* Function Body - URI *)
    $uri$;
}
>>

// <Sproc procedure_body> or <Sfunc function_body>
subProgram(uri, kind, prog, annotation) ::= <<
(* $annotation$ Body Declaration *)
$kind$( 
  $prog$,
  $uri$
)
>>

// ++++++
packageBody(pkgBodyUri, pkgBodyName, pkgBodyAspectSpecs, pkgBodyDeclItems) ::= <<
(* Package Body Declaration *)
Packagebody (
  (* Package Body - Name *)
  $pkgBodyName$,
  (* Package Body - Specification *)
  $if(pkgBodyAspectSpecs)$
  $pkgBodyAspectSpecs$$else$
  None$endif$, 
  (* Package Body - Declared Items *)
  [
    $pkgBodyDeclItems; separator="; \n"$
  ],
  (* Package Body - URI *)
  $pkgBodyUri$
)
>>

compilationUnit(unitUri, unitName, unitDecl,
  unitExpTypeTable, unitTypeUriTable) ::= <<
(* Compilation Unit Declaration *)
PkgBodyDecl (
  (* Compilation Unit - URI *)
  $unitUri$,
  (* Compilation Unit - Name *)
  $unitName$,
  (* Compilation Unit - Unit Declaration *)
  $unitDecl$,  
  (* Compilation Unit - Type Table *)
  mktype_table{
    tt_ast_table = 
      (* Expression --> TypeNum *) [
        $unitExpTypeTable; separator=" ;\n"$
      ];
    tt_typeuri_table = 
      (* TypeNum --> Type Name *) [
        $unitTypeUriTable; separator=" ;\n"$
      ]
  }
)
>>

mappingTable(key, value) ::= <<
($key$) -> ($value$)
>>

location(line, col, endline, endcol) ::= <<
Loc (($line$, $col$), ($endline$, $endcol$))
>>



