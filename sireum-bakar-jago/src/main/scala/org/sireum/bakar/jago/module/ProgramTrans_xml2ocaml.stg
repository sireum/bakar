// group SPARKTRANS_OCaml_MODEL;

optionVal(value) ::= <<
$if(value)$Some($value$)$else$None$endif$ 
>>

binaryExpr(op, loperand, roperand) ::= <<
Ebinop ($op$, $loperand$, $roperand$)
>>

unaryExpr(op, operand) ::= <<
Eunop ($op$, $operand$)
>>

// identifier is either (1) Bid nat; or (2) Aid nat 
varId(theType, id, annotation) ::= <<
$theType$ $if(annotation)$(*$annotation$*)$endif$ $id$
>>

identifierExpr(id) ::= <<
Evar $id$
>>

// Inductive constant: Type := 
//     | Ointconst: nat -> constant
// the type is "Ointconst", the value is of type nat
// $if(theType)$$theType$ $endif$$constVal$
constant(theType, constVal) ::= <<
$constVal$
>>

constantExpr(constVal) ::= <<
Econst $constVal$
>>

// procedureCall(procName, args) ::= <<
// $procName$($args; separator=", "$)
// >>

seqStmt(stmt1, stmt2) ::= <<
Sseq (
  $stmt1$,
  $stmt2$ )
>>

whileStmt(cond, loopInv, loopBody) ::= <<
Swhile ($cond$, 
  $if(loopInv)$
  $loopInv$$else$
  None$endif$,
  $loopBody$
)
>>

ifStmt(cond, ifBody) ::= <<
Sifthen ($cond$,
  $ifBody$
)
>>

assignStmt(lhs, rhs) ::= <<
Sassign ($lhs$, $rhs$)
>>

param(id, mode, initExp) ::= <<
{ param_ident = $id$; param_mode = $mode$; param_init = $if(initExp)$$initExp$$else$None$endif$ }
>>

subprogAspectSpecs(pre, post) ::= <<
{ pre = 
    (* Precondition *)
    $if(pre)$
    $pre$$else$None$endif$; 
  post = 
    (* Postcondition *)
    $if(post)$
    $post$$else$None$endif$ 
}
>>

// +++++++++
identiferDecl(uri, ids, init) ::= <<
{ local_uri = $uri$; local_idents = [$ids; separator="; "$]; local_init = $if(init)$$init$$else$None$endif$ }
>>

// ++++++
procedureBody(uri, procName, aspectSpecs, params, identDecls, procBody) ::= <<
{ proc_uri = 
    (* Procedure Body - URI *)
    $uri$;
  proc_name = 
    (* Procedure Body - Name *)
    $procName$;
  proc_specs =
    (* Procedure Body - Specification *)
    $if(aspectSpecs)$
    $aspectSpecs$$else$
    None$endif$;
  proc_params = 
    (* Procedure Body - Parameters *)
    $if(params)$Some([
      $params; separator="; \n"$
    ])$else$
    None$endif$;
  proc_defidents = 
    (* Procedure Body - Locally Defined Variables *)
    $if(identDecls)$Some([
      $identDecls; separator="; \n"$
    ])$else$
    None$endif$;
  proc_body =
    (* Procedure Body - Body *)
    $procBody$
}
>>

// ++++
functionBody(uri, funcName, aspectSpecs, returnT, params, identDecls, funcBody) ::= <<
{ fn_uri =   
    (* Function Body - URI *)
    $uri$;
  fn_name =
    (* Function Body - Name *)
    $funcName$;
  fn_specs = 
    (* Function Body - Specification *)
    $if(aspectSpecs)$
    $aspectSpecs$$else$
    None$endif$;
  fn_retT = 
    (* Function Body - Return Type *)
    $returnT$;
  fn_params = 
    (* Function Body - Parameters *)
    $if(params)$Some([
      $params; separator="; \n"$
    ])$else$
    None$endif$;
  fn_defidents = 
    (* Function Body - Locally Defined Variables *)
    $if(identDecls)$Some([
      $identDecls; separator="; \n"$
    ])$else$
    None$endif$;
  fn_body = 
    (* Function Body - Body *)
    $funcBody$
}
>>

// <Sproc procedure_body> or <Sfunc function_body>
subProgram(uri, kind, prog, annotation) ::= <<
(* $annotation$ Body Declaration *)
$kind$( 
  $uri$,
  $prog$
)
>>

// ++++++
packageBody(pkgBodyUri, pkgBodyName, pkgBodyAspectSpecs, pkgBodyDeclItems) ::= <<
(* Package Body Declaration *)
Packagebody (
  (* Package Body - URI *)
  $pkgBodyUri$,
  (* Package Body - Name *)
  $pkgBodyName$,
  (* Package Body - Specification *)
  $if(pkgBodyAspectSpecs)$
  $pkgBodyAspectSpecs$$else$
  None$endif$, 
  (* Package Body - Declared Items *)
  [
    $pkgBodyDeclItems; separator="; \n"$
  ] 
)
>>

compilationUnit(unitUri, unitName, unitDecl,
  unitTypeMap, unitNameMap, unitIdentMap, unitScope) ::= <<
(* Compilation Unit Declaration *)
ComilationUnit (
  (* Compilation Unit - URI *)
  $unitUri$,
  (* Compilation Unit - Name *)
  $unitName$,
  (* Compilation Unit - Location *)
  $unitScope$,
  (* Compilation Unit - Unit Declaration *)
  $unitDecl$,
  (* Compilation Unit - Type Mapping *) (*
    $unitTypeMap$,
  *)
  (* Compilation Unit - Package/Procedure Name Mapping *) (*
    $unitNameMap$,
  *)
  (* Compilation Unit - Global/Local Variable Mapping *) (*
    $unitIdentMap$,
  *)
)
>>

mappingTable(key, value) ::= <<
($key$) -> ($value$)
>>

location(line, col, endline, endcol) ::= <<
Loc ($line$, $col$, $endline$, $endcol$)
>>



